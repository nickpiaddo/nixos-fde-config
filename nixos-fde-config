#!/usr/bin/env bash

# Copyright (c) 2023 Nick Piaddo
# SPDX-License-Identifier: Apache-2.0 OR MIT

################################################################################
# Description
# nixos-fde-config:
#   script for configuring a NixOS system with full disk encryption.
#
#   This script creates a LUKS2 encrypted container on the given main disk,
#   then adds three ext4-formatted LVM volumes (root, swap, home).
#
#   The LUKS2 container's header-file, along with a decryption key-file are
#   added as a compressed, passphrase-protected archive to a UEFI boot partition
#   on the USB boot-key.
#
#   After a successful setup, the boot-key is required to boot the system.
#   You will also need to provide your passphrase to mount the filesystem.
#
################################################################################

# Coding convention
#
# CAPITAL_SNAKE_CASE: global variable
# snake_case: local variable
# camelCase: function

# Script template inspired by
# https://sharats.me/posts/shell-script-best-practices/
set -o errexit
set -o nounset
set -o pipefail
shopt -s globstar
shopt -s nullglob

# Run script `TRACE=1 ./nixos-fde-config [options]' to enable tracing
if [[ "${TRACE-0}" == "1" ]]; then
  set -o xtrace
fi

################################################################################
#                        GLOBAL VARIABLES
############################################################################nÏ–+o
VERSION="##version##"
REVISION="##revision##"
TMP_FILE="/root/.fde-config"
MAIN_DISK=""
BOOT_KEY=""
RAW_ROOT_SIZE=""
ROOT_SIZE=""
RAW_SWAP_SIZE=""
SWAP_SIZE=""
HOME_SIZE=""
WIPE_DISKS=true
RESUME=false
CHECKPOINT_ID=""
RUNNING_TEST=0

################################################################################
#                        HELPER FUNCTIONS
################################################################################

#### OUTPUT FORMATTING FUNCTIONS

function formatText {
  # escape character start
  local on="$1"
  # escape character end
  local off="$2"
  local text="$3"

  echo -ne "${on}${text}${off}"
}

function bold { formatText "$(tput -T ansi bold)" "$(tput -T ansi sgr0)" "$1"; }
function redbg { formatText "$(tput -T ansi setab 1)" "$(tput -T ansi sgr0)" "$1"; }
function underline { formatText "$(tput -T ansi smul)" "$(tput -T ansi rmul)" "$1"; }
function yellowbg { formatText "$(tput -T ansi setab 3)" "$(tput -T ansi sgr0)" "$1"; }

function heading { printf "%s\n" "$(bold "$1") "; }

function subheading { echo "> $1"; }

#### MAIN HELPER FUNCTIONS

######################################################################
# Print version.
# Arguments:
#   None
# Outputs:
#   Command version
######################################################################
function printVersion {
  echo "$(basename "$0") ${VERSION} ${REVISION}"
}

######################################################################
# Print usage.
# Arguments:
#   None
# Outputs:
#   Usage instructions
######################################################################
function printUsage {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0
END
}

######################################################################
# Print help page.
# Arguments:
#   None
# Outputs:
#   Usage manual
######################################################################
function printHelp {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0

   $(bold DESCRIPTION)

       $(basename "$0") is a setup script for configuring a NixOS system with
       full disk encryption.

       It creates a LUKS2 encrypted container on the given main disk, then adds
       up to three ext4-formatted LVM volumes (root, swap, home).

       The LUKS2 container's header-file, along with a decryption key-file are
       added as a compressed, passphrase-protected archive to a UEFI boot
       partition on the USB bootkey.

       After a successful setup, the bootkey is required to boot the system.
       You will also need to provide your passphrase to mount the filesystem.

       $(bold Note:) When sizing your partitions, take into account that $(bold 16MiB)
             are reserved on the main disk for GPT and LVM metadata.

   $(bold OPTIONS)

       -h, --help               Display this help and exit.
       -z, --resume             Resume execution from the last successful step
                                before interruption.
       --version                Print script version string.

       -m, --main-disk DEVPATH  Specify where to install NixOS.
       -b, --boot-key  DEVPATH  Specify where to put the boot partition.
       -R, --root-size SIZE     Specify the root partition size.
       -S, --swap-size SIZE     Specify the swap partition size.
       -H, --home-size SIZE     Specify the home partition size. (Optional)
                                (default: remaining free space after root
                                 and swap partitions)

       --skip-wipe-disks        Skip wiping disks with random data before
                                formatting.

                                Wiping a disk with random data, before creating
                                the LUKS container, helps hide the size of the
                                encrypted content and gives you plausible
                                deniability about its very existence.
                                $(bold "Use this option at your own risk!")

       Command parameters:

       DEVPATH the absolute path to a disk (e.g. /dev/sda).

       SIZE the integer partition size in bytes. Must be at least 8GiB for the
       root partition. Otherwise, either 0 or at least 4MiB.

       Optional suffixes k or K (kibibyte, 1024 bytes), M (mebibyte, 1024k),
       G (gibibyte, 1024M), and T (tebibyte, 1024G) are supported.
END
}

#### ERROR MANAGEMENT FUNCTIONS

######################################################################
# Print error message and terminate program.
# Arguments:
#   Error message
# Outputs:
#   Writes error message to stderr
# Returns:
#   Exit code 1
######################################################################
function error {
  echo -e "$(redbg Error:) $*" >&2
  exit 1
}

######################################################################
# Print recovery help message after script execution error.
# Arguments:
#   None
# Outputs:
#   A how-to-recover message on error
# Returns:
#   1
######################################################################
function messageOnAbort {
  if [[ "$?" -ne 0 ]]; then
    cat <<END

$(redbg "An error occurred during execution. Aborting...")
After resolving the issue, you can resume execution with the command:

    $(basename "$0") --resume

END
    return 1
  fi
}

######################################################################
# Execute an error function if a predicate function returns false.
# Arguments:
#   Predicate function
#   Argument of the predicate function
#   Error function to execute if assertion is false
#   Error message
# Outputs:
#   Nothing if the predicate is true. The error function's output
#   otherwise.
######################################################################
function assert {
  local pred_fun="$1"
  local pred_arg="$2"
  local error_fun="$3"
  local error_arg="$4"

  if ! $pred_fun "${pred_arg}"; then
    $error_fun "${error_arg}"
  fi
}

######################################################################
# Print warning message.
# Arguments:
#   Warning message
# Outputs:
#   Writes warning message to stderr
######################################################################
function warn {
  echo -e "$(yellowbg WARNING:) $1" >&2
}

######################################################################
# Ask for confirmation after a warning.
# Arguments:
#  Warning message
# Outputs:
#   Writes warning to stderr
# Returns:
#   0 if action is confirmed, non-zero otherwise
######################################################################
function confirmContinue {
  local message="$1"
  local reply

  warn "${message}"
  read -r -p "Would you like to continue? [y/N] " reply

  if [[ "${reply}" != y ]]; then
    exit 1
  fi
}

#### CONVERSION FUNCTIONS

######################################################################
# Convert a short option to its long version.
# Arguments:
#   Short option
# Returns:
#   Long version of the given short option
#   Empty string otherwise
######################################################################
function toLongOption {
  local short_option="$1"

  case "${short_option}" in
    '-h') echo '--help' ;;
    '-y') echo '--version' ;;
    '-z') echo '--resume' ;;
    '-m') echo '--main-disk' ;;
    '-b') echo '--boot-key' ;;
    '-R') echo '--root-size' ;;
    '-S') echo '--swap-size' ;;
    *) echo "" ;;
  esac
}

######################################################################
# Extract integer prefix from a string.
# Arguments:
#   A string starting with an integer
# Returns:
#   The integer prefix of the string
#   An empty string  if there is no prefix
######################################################################
function parseIntPrefix {
  local string="$1"

  if [[ "${string}" =~ ^[0-9]+ ]]; then
    echo "${BASH_REMATCH[0]}"
  fi
}

######################################################################
# Convert a size denomination to its equivalent in bytes.
# Arguments:
#   Size with optional unit
# Returns:
#   Size in bytes
######################################################################
function toBytes {
  local size="$1"

  local one_KiB=1024
  local one_MiB=$((1024 * one_KiB))
  local one_GiB=$((1024 * one_MiB))
  local one_TiB=$((1024 * one_GiB))

  local size_in_bytes

  # Kibibytes
  if [[ "${size}" = *[kK] ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_KiB))
  # Mebibytes
  elif [[ "${size}" = *M ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_MiB))
  # Gibibytes
  elif [[ "${size}" = *G ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_GiB))
  # Tebibytes
  elif [[ "${size}" = *T ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_TiB))
  # Bytes
  else
    size_in_bytes=${size}
  fi

  echo "${size_in_bytes}"
}

#### UTILITY FUNCTIONS

######################################################################
# Concatenate two strings separated by the given separator character
# if the two strings are non-empty. Returns an empty string or whichever
# of the two is non-empty otherwise.
#
# Examples:
#
#   concat ';' '' ''       --> ''
#   concat ';' '' 'bar'    --> 'bar'
#   concat ';' 'foo' ''    --> 'foo'
#   concat ';' 'foo' 'bar' --> 'foo;bar'
#
# Arguments:
#   Separator character
#   First string
#   Second string
# Returns:
#   Concatenated strings
######################################################################
function concat {
  # No argument or just the separator
  if [[ $# -eq 0 || $# -eq 1 ]]; then
    echo ""
  # Separator + one string
  elif [[ $# -eq 2 ]]; then
    echo -e "$2"
  # Separator + two strings
  else
    local separator="$1"
    local first="$2"
    local second="$3"

    # concat ';' '' ''
    if [[ -z "${first}" && -z "${second}" ]]; then
      echo ""
    # concat ';' '' 'bar'
    elif [[ -z "${first}" && -n "${second}" ]]; then
      echo -e "${second}"
    # concat ';' 'foo' ''
    elif [[ -n "${first}" && -z "${second}" ]]; then
      echo -e "${first}"
    # concat ';' 'foo' 'bar'
    else
      echo -e "${first}${separator}${second}"
    fi
  fi
}

######################################################################
# Find the option at the given index in the string.
# Arguments:
#   Index
#   String
# Returns:
#   First option at index
#   Empty string if there is none
######################################################################
function findOptionAt {
  local index="$1"
  local argument_list="$2"
  echo "${argument_list}" | cut --delimiter=' ' --fields="${index}"
}

######################################################################
# Find a device mount points.
# Arguments:
#   Device path
# Returns:
#   A list of mount points
#   Empty string if there are none
######################################################################
function findMountPoints {
  local device="$1"
  lsblk --noheadings --list --output MOUNTPOINTS "${device}" \
    | sed '/^\s*$/d' \
    | tr "\n" " " \
    | sed 's/\s*$//'
}

#### STATE MANAGEMENT FUNCTIONS

######################################################################
# Load saved global options variables from disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   None
# Returns:
#   Options variables set to their last saved state
######################################################################
function loadCheckPoint {
  read -r MAIN_DISK BOOT_KEY ROOT_SIZE SWAP_SIZE \
    HOME_SIZE WIPE_DISKS CHECKPOINT_ID <<<"$(<${TMP_FILE})"
}

######################################################################
# Save global options variables to disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   Check point identifier
# Outputs:
#  Global options variables to disk
######################################################################
function saveCheckPoint {
  CHECKPOINT_ID="$1"
  echo -n "${MAIN_DISK} ${BOOT_KEY} ${ROOT_SIZE} ${SWAP_SIZE} \
    ${HOME_SIZE} ${WIPE_DISKS} ${CHECKPOINT_ID}" >|"${TMP_FILE}"
}

#### PREDICATE FUNCTIONS

######################################################################
# Test if unit tests are being run.
# Arguments:
#   None
# Returns:
#   True if unit tests are running
#   False otherwise
######################################################################
function isRunningUnitTest { [[ ${RUNNING_TEST} -eq 1 ]]; }

######################################################################
# Test if a device is a block device.
# Arguments:
#   Device path
# Returns:
#   True if the device is a block device
#   False otherwise
######################################################################
function isBlockDevice { [[ -b "$1" ]]; }

######################################################################
# Test if the size of a device is at least n bytes.
# Arguments:
#   Minimum size in bytes
#   Device path
# Returns:
#   True if the size of a device is at least n bytes
#   False otherwise
######################################################################
function hasDeviceAtLeastNBytes {
  local minimum="$1"
  local device="$2"

  local size
  size=$(blockdev --getsize64 "${device}")

  [[ ${size} -ge ${minimum} ]]
}

function hasDeviceAtLeast2GiB { hasDeviceAtLeastNBytes "$(toBytes 2G)" "$1"; }
function hasDeviceAtLeast16GiB { hasDeviceAtLeastNBytes "$(toBytes 16G)" "$1"; }

######################################################################
# Test if a device is NOT mounted.
# Arguments:
#   Device path
# Returns:
#   True if the device NOT mounted
#   False otherwise
######################################################################
function isNotMounted {
  local device="$1"

  local mount_points
  mount_points="$(lsblk --list --noheadings --output MOUNTPOINTS "${device}")"
  [[ -z "${mount_points}" ]]
}

######################################################################
# Test if a variable is set.
# Arguments:
#   Variable value
# Returns:
#   True if variable is set
#   False otherwise
######################################################################
function isSet { [[ -n "$1" ]]; }

######################################################################
# Test if a device path is not identical to the main disk's.
# Arguments:
#   Device path
# Returns:
#   True device paths differ
#   False otherwise
######################################################################
function isNotMainDisk { [[ "${MAIN_DISK}" != "$1" ]]; }

######################################################################
# Test if the size is at least as large as the given lower limit.
# Arguments:
#   Lower limit in bytes
#   Size in bytes
# Returns:
#   True if the size is greater than or equal to a lower limit
#   False otherwise
######################################################################
function isAtLeastNBytes {
  local lower_limit="$1"
  local size_in_bytes="$2"

  [[ ${size_in_bytes} -ge ${lower_limit} ]]
}

function isAtLeast8GiB { isAtLeastNBytes "$(toBytes 8G)" "$1"; }

######################################################################
# Test if an expression of size is well formed.
# Arguments:
#   Size in with optional unit
# Returns:
#   True if the size is well formed
#   False otherwise
######################################################################
function isValidSize { [[ "$1" =~ (^[0-9]+$)|(^[0-9]+[kKMGT]$) ]]; }

######################################################################
# Test if a disk size in bytes is zero or at least 4MiB
# Arguments:
#   Size in bytes
# Returns:
#   True if the size is zero or 4MiB
#   False otherwise
######################################################################
function isZeroOrAtLeast4MiB { [[ $1 -eq 0 || $1 -ge $(toBytes 4M) ]]; }

######################################################################
# Test if an integer is not zero
# Arguments:
#   Integer value
# Returns:
#   True if an integer is not equal to zero
#   False otherwise
######################################################################
function isNotZero { [[ "$1" -ne 0 ]]; }

#### PARSER FUNCTIONS

######################################################################
# Run a parser on a command line option value.
# Globals:
#   OPTARG
# Arguments:
#   Parser function
#   Command line option (short form)
#   Previous raw option value
# Outputs:
#  An error if the option was redefined with a conflicting value.
# Returns:
#   A parsed option value.
######################################################################
function run {
  local parserFunction="$1"
  local short_option="$2"
  local prev_value="$3"

  case "${prev_value}" in
    "" | "${OPTARG}") $parserFunction "${OPTARG}" ;;
    *) error "option $(concat ', ' "-${short_option}" "$(toLongOption "-${short_option}")") redefined with conflicting values: '${prev_value}' vs '${OPTARG}'" ;;
  esac
}

######################################################################
# Parse main-disk option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseMaindisk {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume"
  assert hasDeviceAtLeast16GiB "${device_path}" \
    error "'${device_path}' must have at least 16GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse boot-key option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseBootkey {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume"
  assert hasDeviceAtLeast2GiB "${device_path}" \
    error "'${device_path}' must have at least 2GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse root-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseRootSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isAtLeast8GiB "${size_in_bytes}" \
    error "A root partition must have at least 8GiB available. Please allocate more space."

  echo "${size_in_bytes}"
}

######################################################################
# Parse swap-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseSwapSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isZeroOrAtLeast4MiB "${size_in_bytes}" \
    error "Swap size must be either 0 or at least 4MiB."

  echo "${size_in_bytes}"
}

################################################################################
#                        MAIN PROGRAM
################################################################################

if [[ $# -eq 0 ]]; then
  printUsage
  exit 1
fi

# From https://stackoverflow.com/a/30026641
# Long option to short option substitution
for arg in "$@"; do
  shift
  case "$arg" in
    '--help') set -- "$@" '-h' ;;
    '--boot-key') set -- "$@" '-b' ;;
    '--main-disk') set -- "$@" '-m' ;;
    '--resume') set -- "$@" '-z' ;;
    '--root-size') set -- "$@" '-R' ;;
    '--swap-size') set -- "$@" '-S' ;;
    '--version') set -- "$@" '-y' ;;
    *) set -- "$@" "$arg" ;;
  esac
done

# Parse short option value
OPTIND=1
while getopts ":hm:b:R:S:tyz" short_option; do
  case "${short_option}" in
    h)
      printHelp
      exit 0
      ;;
    m) MAIN_DISK="$(run parseMaindisk "${short_option}" "${MAIN_DISK}")" ;;
    b) BOOT_KEY="$(run parseBootkey "${short_option}" "${BOOT_KEY}")" ;;
    R)
      ROOT_SIZE="$(run parseRootSize "${short_option}" "${RAW_ROOT_SIZE}")"
      RAW_ROOT_SIZE="${OPTARG}"
      ;;
    S)
      SWAP_SIZE="$(run parseSwapSize "${short_option}" "${RAW_SWAP_SIZE}")"
      RAW_SWAP_SIZE="${OPTARG}"
      ;;
    t) RUNNING_TEST=1 ;;
    y)
      printVersion
      exit 0
      ;;
    z) RESUME=true ;;
    :) error "option $(concat ', ' "-${OPTARG}" "$(toLongOption "-${OPTARG}")") requires an argument." ;;
    ?)
      case "${OPTARG}" in
        '-') INDEX=${OPTIND} ;;
        *) INDEX=$((OPTIND - 1)) ;;
      esac
      error "unknown option: $(findOptionAt "${INDEX}" "${*}")"
      ;;
  esac
done

# Raise an error if script not run by a user with root privileges
if ! isRunningUnitTest; then
  if [[ $(id -u) -ne 0 ]]; then
    echo -e "run $(basename "$0") as root, or issue the command\n"
    echo "    $(bold sudo) $(basename "$0") $*"
    exit 1
  fi
fi

# Remove parsed options from script argument list
shift $((OPTIND - 1))

if [[ "${RESUME}" == "true" ]]; then
  # Restore global options variables to their last saved state
  loadCheckPoint
  heading "********** Resuming execution              **********"
fi

# Check that required global variables are set
assert isSet "${MAIN_DISK}" \
  error "the option '-m, --main-disk' is required."
assert isSet "${BOOT_KEY}" \
  error "the option '-b, --boot-key' is required."
assert isSet "${ROOT_SIZE}" \
  error "the option '-R, --root-size' is required."
assert isSet "${SWAP_SIZE}" \
  error "the option '-S, --swap-size' is required."

# Check that we are NOT Setting up the system and the boot-key on the same disk
assert isNotMainDisk "${BOOT_KEY}" \
  error "options main-disk and boot-key refer to the same device: ${BOOT_KEY}"

if [[ "${RESUME}" == false ]]; then
  # Warn about zero-sized partitions and ask for confirmation
  assert isNotZero "${SWAP_SIZE}" \
    confirmContinue "no space allocated for SWAP."
fi

# Stop script execution beyond this point and signal success
if isRunningUnitTest; then
  exit 0
fi

trap messageOnAbort EXIT
