#!/usr/bin/env bash

# Copyright (c) 2023 Nick Piaddo
# SPDX-License-Identifier: Apache-2.0 OR MIT

################################################################################
# Description
# nixos-fde-config:
#   script for configuring a NixOS system with full disk encryption.
#
#   This script creates a LUKS2 encrypted container on the given main disk,
#   then adds three ext4-formatted LVM volumes (root, swap, home).
#
#   The LUKS2 container's header-file, along with a decryption key-file are
#   added as a compressed, passphrase-protected archive to a UEFI boot partition
#   on the USB boot-key.
#
#   After a successful setup, the boot-key is required to boot the system.
#   You will also need to provide your passphrase to mount the filesystem.
#
################################################################################

# Coding convention
#
# CAPITAL_SNAKE_CASE: global variable
# snake_case: local variable
# camelCase: function

# Script template inspired by
# https://sharats.me/posts/shell-script-best-practices/
set -o errexit
set -o nounset
set -o pipefail
shopt -s globstar
shopt -s nullglob

# Run script `TRACE=1 ./nixos-fde-config [options]' to enable tracing
if [[ "${TRACE-0}" == "1" ]]; then
  set -o xtrace
fi

################################################################################
#                        GLOBAL VARIABLES
############################################################################nÏ–+o
VERSION="##version##"
REVISION="##revision##"
TMP_FILE="/root/.fde-config"
MAIN_DISK=""
BOOT_KEY=""
RAW_ROOT_SIZE=""
ROOT_SIZE=""
RAW_SWAP_SIZE=""
SWAP_SIZE=""
RAW_HOME_SIZE=""
HOME_SIZE=""
WIPE_DISKS=true
RESUME=false
CHECKPOINT_ID=""
RUNNING_TEST=0

################################################################################
#                        HELPER FUNCTIONS
################################################################################

#### OUTPUT FORMATTING FUNCTIONS

function formatText {
  # escape character start
  local on="$1"
  # escape character end
  local off="$2"
  local text="$3"

  echo -ne "${on}${text}${off}"
}

function bold { formatText "$(tput -T ansi bold)" "$(tput -T ansi sgr0)" "$1"; }
function redbg { formatText "$(tput -T ansi setab 1)" "$(tput -T ansi sgr0)" "$1"; }
function underline { formatText "$(tput -T ansi smul)" "$(tput -T ansi rmul)" "$1"; }
function yellowbg { formatText "$(tput -T ansi setab 3)" "$(tput -T ansi sgr0)" "$1"; }

function heading { printf "%s\n" "$(bold "$1") "; }

function subheading { echo "> $1"; }

#### MAIN HELPER FUNCTIONS

######################################################################
# Print version.
# Arguments:
#   None
# Outputs:
#   Command version
######################################################################
function printVersion {
  echo "$(basename "$0") ${VERSION} ${REVISION}"
}

######################################################################
# Print usage.
# Arguments:
#   None
# Outputs:
#   Usage instructions
######################################################################
function printUsage {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0
END
}

######################################################################
# Print help page.
# Arguments:
#   None
# Outputs:
#   Usage manual
######################################################################
function printHelp {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0

   $(bold DESCRIPTION)

       $(basename "$0") is a setup script for configuring a NixOS system with
       full disk encryption.

       It creates a LUKS2 encrypted container on the given main disk, then adds
       up to three ext4-formatted LVM volumes (root, swap, home).

       The LUKS2 container's header-file, along with a decryption key-file are
       added as a compressed, passphrase-protected archive to a UEFI boot
       partition on the USB bootkey.

       After a successful setup, the bootkey is required to boot the system.
       You will also need to provide your passphrase to mount the filesystem.

       $(bold Note:) When sizing your partitions, take into account that $(bold 16MiB)
             are reserved on the main disk for GPT and LVM metadata.

   $(bold OPTIONS)

       -h, --help               Display this help and exit.
       -z, --resume             Resume execution from the last successful step
                                before interruption.
       --version                Print script version string.

       -m, --main-disk DEVPATH  Specify where to install NixOS.
       -b, --boot-key  DEVPATH  Specify where to put the boot partition.
       -R, --root-size SIZE     Specify the root partition size.
       -S, --swap-size SIZE     Specify the swap partition size.
       -H, --home-size SIZE     Specify the home partition size. (Optional)
                                (default: remaining free space after root
                                 and swap partitions)

       --skip-wipe-disks        Skip wiping disks with random data before
                                formatting.

                                Wiping a disk with random data, before creating
                                the LUKS container, helps hide the size of the
                                encrypted content and gives you plausible
                                deniability about its very existence.
                                $(bold "Use this option at your own risk!")

       Command parameters:

       DEVPATH the absolute path to a disk (e.g. /dev/sda).

       SIZE the integer partition size in bytes. Must be at least 8GiB for the
       root partition. Otherwise, either 0 or at least 4MiB.

       Optional suffixes k or K (kibibyte, 1024 bytes), M (mebibyte, 1024k),
       G (gibibyte, 1024M), and T (tebibyte, 1024G) are supported.
END
}

#### ERROR MANAGEMENT FUNCTIONS

######################################################################
# Print error message and terminate program.
# Arguments:
#   Error message
# Outputs:
#   Writes error message to stderr
# Returns:
#   Exit code 1
######################################################################
function error {
  echo -e "$(redbg Error:) $*" >&2
  exit 1
}

######################################################################
# Print recovery help message after script execution error.
# Arguments:
#   None
# Outputs:
#   A how-to-recover message on error
# Returns:
#   1
######################################################################
function messageOnAbort {
  if [[ "$?" -ne 0 ]]; then
    cat <<END

$(redbg "An error occurred during execution. Aborting...")
After resolving the issue, you can resume execution with the command:

    $(basename "$0") --resume

END
    return 1
  fi
}

######################################################################
# Execute an error function if a predicate function returns false.
# Arguments:
#   Predicate function
#   Argument of the predicate function
#   Error function to execute if assertion is false
#   Error message
# Outputs:
#   Nothing if the predicate is true. The error function's output
#   otherwise.
######################################################################
function assert {
  local pred_fun="$1"
  local pred_arg="$2"
  local error_fun="$3"
  local error_arg="$4"

  if ! $pred_fun "${pred_arg}"; then
    $error_fun "${error_arg}"
  fi
}

######################################################################
# Print warning message.
# Arguments:
#   Warning message
# Outputs:
#   Writes warning message to stderr
######################################################################
function warn {
  echo -e "$(yellowbg WARNING:) $1" >&2
}

######################################################################
# Ask for confirmation after a warning.
# Arguments:
#  Warning message
# Outputs:
#   Writes warning to stderr
# Returns:
#   0 if action is confirmed, non-zero otherwise
######################################################################
function confirmContinue {
  local message="$1"
  local reply

  warn "${message}"
  read -r -p "Would you like to continue? [y/N] " reply

  if [[ "${reply}" != y ]]; then
    exit 1
  fi
}

#### CONVERSION FUNCTIONS

######################################################################
# Convert a short option to its long version.
# Arguments:
#   Short option
# Returns:
#   Long version of the given short option
#   Empty string otherwise
######################################################################
function toLongOption {
  local short_option="$1"

  case "${short_option}" in
    '-h') echo '--help' ;;
    '-y') echo '--version' ;;
    '-z') echo '--resume' ;;
    '-m') echo '--main-disk' ;;
    '-b') echo '--boot-key' ;;
    '-R') echo '--root-size' ;;
    '-S') echo '--swap-size' ;;
    '-H') echo '--home-size' ;;
    '-x') echo '--skip-wipe-disks' ;;
    *) echo "" ;;
  esac
}

######################################################################
# Extract integer prefix from a string.
# Arguments:
#   A string starting with an integer
# Returns:
#   The integer prefix of the string
#   An empty string  if there is no prefix
######################################################################
function parseIntPrefix {
  local string="$1"

  if [[ "${string}" =~ ^[0-9]+ ]]; then
    echo "${BASH_REMATCH[0]}"
  fi
}

######################################################################
# Convert a size denomination to its equivalent in bytes.
# Arguments:
#   Size with optional unit
# Returns:
#   Size in bytes
######################################################################
function toBytes {
  local size="$1"

  local one_KiB=1024
  local one_MiB=$((1024 * one_KiB))
  local one_GiB=$((1024 * one_MiB))
  local one_TiB=$((1024 * one_GiB))

  local size_in_bytes

  # Kibibytes
  if [[ "${size}" = *[kK] ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_KiB))
  # Mebibytes
  elif [[ "${size}" = *M ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_MiB))
  # Gibibytes
  elif [[ "${size}" = *G ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_GiB))
  # Tebibytes
  elif [[ "${size}" = *T ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_TiB))
  # Bytes
  else
    size_in_bytes=${size}
  fi

  echo "${size_in_bytes}"
}

#### UTILITY FUNCTIONS

######################################################################
# Concatenate two strings separated by the given separator character
# if the two strings are non-empty. Returns an empty string or whichever
# of the two is non-empty otherwise.
#
# Examples:
#
#   concat ';' '' ''       --> ''
#   concat ';' '' 'bar'    --> 'bar'
#   concat ';' 'foo' ''    --> 'foo'
#   concat ';' 'foo' 'bar' --> 'foo;bar'
#
# Arguments:
#   Separator character
#   First string
#   Second string
# Returns:
#   Concatenated strings
######################################################################
function concat {
  # No argument or just the separator
  if [[ $# -eq 0 || $# -eq 1 ]]; then
    echo ""
  # Separator + one string
  elif [[ $# -eq 2 ]]; then
    echo -e "$2"
  # Separator + two strings
  else
    local separator="$1"
    local first="$2"
    local second="$3"

    # concat ';' '' ''
    if [[ -z "${first}" && -z "${second}" ]]; then
      echo ""
    # concat ';' '' 'bar'
    elif [[ -z "${first}" && -n "${second}" ]]; then
      echo -e "${second}"
    # concat ';' 'foo' ''
    elif [[ -n "${first}" && -z "${second}" ]]; then
      echo -e "${first}"
    # concat ';' 'foo' 'bar'
    else
      echo -e "${first}${separator}${second}"
    fi
  fi
}

######################################################################
# Find the option at the given index in the string.
# Arguments:
#   Index
#   String
# Returns:
#   First option at index
#   Empty string if there is none
######################################################################
function findOptionAt {
  local index="$1"
  local argument_list="$2"
  echo "${argument_list}" | cut --delimiter=' ' --fields="${index}"
}

######################################################################
# Find a device mount points.
# Arguments:
#   Device path
# Returns:
#   A list of mount points
#   Empty string if there are none
######################################################################
function findMountPoints {
  local device="$1"
  lsblk --noheadings --list --output MOUNTPOINTS "${device}" \
    | sed '/^\s*$/d' \
    | tr "\n" " " \
    | sed 's/\s*$//'
}

######################################################################
# Divide two integers, then truncate the result after the first
# non-zero decimal digit
# Arguments:
#   Numerator
#   Denominator
# Returns:
#   The ratio of numerator to denominator truncated after
#   the first non-zero decimal digit
######################################################################
function truncDivide {
  local numerator="$1"
  local denominator="$2"

  local ratio
  ratio=$(awk "BEGIN {print ${numerator} / ${denominator}}")
  if isInteger "${ratio}"; then
    echo "${ratio}"
  else
    local integer_part
    local fractional_part
    local index_first_non_zero=0

    integer_part=$(echo "${ratio}" | cut -d'.' -f1)
    fractional_part=$(echo "${ratio}" | cut -d'.' -f2)

    for ((i = 0; i < ${#fractional_part}; i++)); do
      if [[ "${fractional_part:$i:1}" != "0" ]]; then
        index_first_non_zero=$i
        break
      fi
    done

    local end=$((index_first_non_zero + 1))
    echo "${integer_part}.${fractional_part:0:$end}"
  fi

}

######################################################################
# Convert size in bytes to their closest unit multiple.
# Arguments:
#   An integer
# Returns:
#   The size with its appropriate unit (KiB, MiB,...)
######################################################################
function byteToString {
  local size_in_bytes="$1"

  local one_KiB=1024
  local metric_prefix="KMGTPEZYRQ"

  local power
  local unit
  local ratio

  if [[ ${size_in_bytes} -lt ${one_KiB} ]]; then
    unit="b"
    ratio=${size_in_bytes}
  else
    power=$(awk "BEGIN { print int(log(${size_in_bytes}) / log(${one_KiB})) }")
    unit="$(printf "%s%s" "${metric_prefix:((power - 1)):1}" "iB")"
    ratio=$(truncDivide "${size_in_bytes}" "$((one_KiB ** power))")
  fi

  echo "${ratio}${unit}"
}

######################################################################
# Largest of two integers.
# Arguments:
#   First integer
#   Second integer
# Returns:
#   Largest integer value
######################################################################
function max {
  local first="$1"
  local second="$2"

  if [[ "${first}" -gt "${second}" ]]; then
    echo "${first}"
  else
    echo "${second}"
  fi
}

######################################################################
# List partitions on device.
# Arguments:
#   Absolute device path
# Returns:
#   A list of device partitions
#   Empty string, if there are none
######################################################################
function listPartitions {
  local device="$1"

  for part_num in $(parted -m "${device}" print 2>/dev/null \
    | grep -P "^[0-9]+:" | cut -d ':' -f 1); do
    echo "${device}${part_num}"
  done
}

######################################################################
# List the files on a partition ordered by decreasing order of size.
# Arguments:
#   File system type
#   Partition
# Returns:
#   A list of the n largest files on the partition
#   Empty string, if there are none
######################################################################
function listFilesOnPartition {
  local fs_type="$1"
  local partition="$2"
  local files

  if [[ -z "${fs_type}" ]]; then
    files="no file system"
  else
    local mount_point
    mount_point="$(lsblk --list --noheadings --output MOUNTPOINTS "${partition}")"

    # Partition NOT mounted
    if [[ -z "${mount_point}" ]]; then
      # Mount partition (read only)
      local tmp_dir
      tmp_dir="$(mktemp --directory --tmpdir=/tmp tmp-mount.XXXXXXXXXX)"
      mount --types "${fs_type}" --options noatime,noexec,ro "${partition}" "${tmp_dir}"

      # List files
      files="$(find "${tmp_dir}" -type f -exec ls -lSh {} + 2>/dev/null \
        | sed "s_""${tmp_dir}/""__")"

      if [[ -z "${files}" ]]; then
        files="no files"
      fi

      # Unmount partition
      umount "${tmp_dir}" 2>/dev/null
      rmdir "${tmp_dir}"
    else
      files="$(find "${mount_point}" -type f -exec ls -lSh {} + 2>/dev/null)"
    fi
  fi

  echo "${files}"
}

######################################################################
# List the N largest files on a partition.
# Arguments:
#   Maximum number of files
#   Device partition
# Returns:
#   A list of the n largest files on the partition
#   Empty string, if there are none
######################################################################
function listNLargestFilesOnPartition {
  local limit="$1"
  local partition="$2"

  local part_info
  local part_type
  local fs_type
  local files
  local nb_lines

  part_info="$(lsblk --list --noheadings --output TYPE,FSTYPE "${partition}" -- 2>/dev/null)"
  part_type="$(echo "${part_info}" | awk '{print $1}')"
  fs_type="$(echo "${part_info}" | awk '{print $2}')"

  case "${part_type}" in
    'crypt') files="*** encrypted ***" ;;
    *) files="$(listFilesOnPartition "${fs_type}" "${partition}")" ;;
  esac

  printf "%s:\n%s\n" "$(bold "${partition}")" "$(echo "${files}" | head --lines="${limit}")"

  nb_lines=$(echo "${files}" | wc --lines)

  if [[ ${nb_lines} -gt ${limit} ]]; then
    printf "... truncated ...\n\n"
  fi
}

function list5LargestFilesOnPartition { listNLargestFilesOnPartition 5 "$1"; }

######################################################################
# Print summary of partition structure.
# Arguments:
#   Main disk path
#   Main disk size
#   Boot key path
#   Boot key size
#   Root partition size
#   Swap partition size
#   Homw partition size
# Outputs:
#   Summary of partition structure
######################################################################
function printSummary {
  local main_disk="$1"
  local main_disk_size="$2"
  local boot_key="$3"
  local boot_key_size="$4"
  local root_size="$5"
  local swap_size="$6"
  local home_size="$7"

  main_disk_size="$(byteToString "${main_disk_size}")"
  boot_key_size="$(byteToString "${boot_key_size}")"

  main_disk="$(basename "${main_disk}")"
  boot_key="$(basename "${boot_key}")"

  root_size="$(byteToString "${root_size}")"
  swap_size="$(byteToString "${swap_size}")"
  home_size="$(byteToString "${home_size}")"

  printf "\nCreating a NixOS system with the following partition layout:\n\n"
  printf "%s\n" "$(bold "main disk:")"
  printf "  %-19s  %8s   %s\n" "NAME" "SIZE" "TYPE"
  printf "  %-19s  %8s   %s\n" "${main_disk}" "${main_disk_size}" "disk"
  printf "  %-23s  %8s   %s\n" "â””â”€lukscontainer" "${main_disk_size}" "crypt"

  # No home or swap partitions
  if [[ ${SWAP_SIZE} -eq 0 && ${HOME_SIZE} -eq 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  â””â”€-root" "${root_size}" "lvm"
  # One of or both home and swap partitions
  else
    printf "  %-23s  %8s   %s\n" "  â”œâ”€-root" "${root_size}" "lvm"
  fi

  # Only a swap partitions
  if [[ ${SWAP_SIZE} -gt 0 && ${HOME_SIZE} -eq 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  â””â”€-swap" "${swap_size}" "lvm"
  # Both home and swap partitions
  elif [[ ${SWAP_SIZE} -gt 0 && ${HOME_SIZE} -gt 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  â”œâ”€-swap" "${swap_size}" "lvm"
  fi

  if [[ ${HOME_SIZE} -gt 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  â””â”€-home" "${home_size}" "lvm"
  fi

  printf "\n"
  printf "%s\n" "$(bold "bootkey:")"
  printf "  %-19s  %8s   %s\n" "NAME" "SIZE" "TYPE"
  printf "  %-19s  %8s   %s\n" "${boot_key}" "${boot_key_size}" "disk"
  printf "  %-23s  %8s   %s\n" "â””â”€${boot_key}1" "2GiB" "part"
  printf "\n"
}

######################################################################
# Print a message and count down for n seconds.
# Arguments:
#   Duration
#   Message
# Outputs:
#   Message
######################################################################
function countDown {
  local duration="$1"
  local message="$2"

  echo -n "${message}"

  for i in $(seq "${duration}"); do
    echo -n "."
    sleep 1
  done
  echo ""
}

#### STATE MANAGEMENT FUNCTIONS

######################################################################
# Load saved global options variables from disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   None
# Returns:
#   Options variables set to their last saved state
######################################################################
function loadCheckPoint {
  read -r MAIN_DISK BOOT_KEY ROOT_SIZE SWAP_SIZE \
    HOME_SIZE WIPE_DISKS CHECKPOINT_ID <<<"$(<${TMP_FILE})"
}

######################################################################
# Save global options variables to disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   Check point identifier
# Outputs:
#  Global options variables to disk
######################################################################
function saveCheckPoint {
  CHECKPOINT_ID="$1"
  echo -n "${MAIN_DISK} ${BOOT_KEY} ${ROOT_SIZE} ${SWAP_SIZE} \
    ${HOME_SIZE} ${WIPE_DISKS} ${CHECKPOINT_ID}" >|"${TMP_FILE}"
}

#### PREDICATE FUNCTIONS

######################################################################
# Test if unit tests are being run.
# Arguments:
#   None
# Returns:
#   True if unit tests are running
#   False otherwise
######################################################################
function isRunningUnitTest { [[ ${RUNNING_TEST} -eq 1 ]]; }

######################################################################
# Test if a device is a block device.
# Arguments:
#   Device path
# Returns:
#   True if the device is a block device
#   False otherwise
######################################################################
function isBlockDevice { [[ -b "$1" ]]; }

######################################################################
# Test if the size of a device is at least n bytes.
# Arguments:
#   Minimum size in bytes
#   Device path
# Returns:
#   True if the size of a device is at least n bytes
#   False otherwise
######################################################################
function hasDeviceAtLeastNBytes {
  local minimum="$1"
  local device="$2"

  local size
  size=$(blockdev --getsize64 "${device}")

  [[ ${size} -ge ${minimum} ]]
}

function hasDeviceAtLeast2GiB { hasDeviceAtLeastNBytes "$(toBytes 2G)" "$1"; }
function hasDeviceAtLeast16GiB { hasDeviceAtLeastNBytes "$(toBytes 16G)" "$1"; }

######################################################################
# Test if a device is NOT mounted.
# Arguments:
#   Device path
# Returns:
#   True if the device NOT mounted
#   False otherwise
######################################################################
function isNotMounted {
  local device="$1"

  local mount_points
  mount_points="$(lsblk --list --noheadings --output MOUNTPOINTS "${device}")"
  [[ -z "${mount_points}" ]]
}

######################################################################
# Test if a variable is set.
# Arguments:
#   Variable value
# Returns:
#   True if variable is set
#   False otherwise
######################################################################
function isSet { [[ -n "$1" ]]; }

######################################################################
# Test if a device path is not identical to the main disk's.
# Arguments:
#   Device path
# Returns:
#   True device paths differ
#   False otherwise
######################################################################
function isNotMainDisk { [[ "${MAIN_DISK}" != "$1" ]]; }

######################################################################
# Test if the size is at least as large as the given lower limit.
# Arguments:
#   Lower limit in bytes
#   Size in bytes
# Returns:
#   True if the size is greater than or equal to a lower limit
#   False otherwise
######################################################################
function isAtLeastNBytes {
  local lower_limit="$1"
  local size_in_bytes="$2"

  [[ ${size_in_bytes} -ge ${lower_limit} ]]
}

function isAtLeast8GiB { isAtLeastNBytes "$(toBytes 8G)" "$1"; }

######################################################################
# Test if an expression of size is well formed.
# Arguments:
#   Size in with optional unit
# Returns:
#   True if the size is well formed
#   False otherwise
######################################################################
function isValidSize { [[ "$1" =~ (^[0-9]+$)|(^[0-9]+[kKMGT]$) ]]; }

######################################################################
# Test if a disk size in bytes is zero or at least 4MiB
# Arguments:
#   Size in bytes
# Returns:
#   True if the size is zero or 4MiB
#   False otherwise
######################################################################
function isZeroOrAtLeast4MiB { [[ $1 -eq 0 || $1 -ge $(toBytes 4M) ]]; }

######################################################################
# Test if an integer is not zero
# Arguments:
#   Integer value
# Returns:
#   True if an integer is not equal to zero
#   False otherwise
######################################################################
function isNotZero { [[ "$1" -ne 0 ]]; }

######################################################################
# Test if a number is an integer
# Arguments:
#   Number
# Returns:
#   True if the number an integer
#   False otherwise
######################################################################
function isInteger { [[ "$1" =~ ^[0-9]+$ ]]; }

######################################################################
# Test if the length of a string is zero.
# Arguments:
#   String
# Returns:
#   True if the string has length zero
#   False otherwise
######################################################################
function isEmpty { [[ -z "$1" ]]; }

######################################################################
# Test if the machine the script is running on is connected to the
# internet
# Arguments:
#   None
# Returns:
#   True if there is an active internet connection
#   False otherwise
######################################################################
function hasInternetAccess {
  ping -qc 3 www.google.com >/dev/null 2>&1
}

#### PARSER FUNCTIONS

######################################################################
# Run a parser on a command line option value.
# Globals:
#   OPTARG
# Arguments:
#   Parser function
#   Command line option (short form)
#   Previous raw option value
# Outputs:
#  An error if the option was redefined with a conflicting value.
# Returns:
#   A parsed option value.
######################################################################
function run {
  local parserFunction="$1"
  local short_option="$2"
  local prev_value="$3"

  case "${prev_value}" in
    "" | "${OPTARG}") $parserFunction "${OPTARG}" ;;
    *) error "option $(concat ', ' "-${short_option}" "$(toLongOption "-${short_option}")") redefined with conflicting values: '${prev_value}' vs '${OPTARG}'" ;;
  esac
}

######################################################################
# Parse main-disk option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseMaindisk {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume"
  assert hasDeviceAtLeast16GiB "${device_path}" \
    error "'${device_path}' must have at least 16GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse boot-key option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseBootkey {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume"
  assert hasDeviceAtLeast2GiB "${device_path}" \
    error "'${device_path}' must have at least 2GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse root-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseRootSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isAtLeast8GiB "${size_in_bytes}" \
    error "A root partition must have at least 8GiB available. Please allocate more space."

  echo "${size_in_bytes}"
}

######################################################################
# Parse swap-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseSwapSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isZeroOrAtLeast4MiB "${size_in_bytes}" \
    error "Swap size must be either 0 or at least 4MiB."

  echo "${size_in_bytes}"
}

######################################################################
# Parse home-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseHomeSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isZeroOrAtLeast4MiB "${size_in_bytes}" \
    error "Home partition size must be either 0 or at least 4MiB."

  echo "${size_in_bytes}"
}

################################################################################
#                        MAIN PROGRAM
################################################################################

if [[ $# -eq 0 ]]; then
  printUsage
  exit 1
fi

# From https://stackoverflow.com/a/30026641
# Long option to short option substitution
for arg in "$@"; do
  shift
  case "$arg" in
    '--help') set -- "$@" '-h' ;;
    '--boot-key') set -- "$@" '-b' ;;
    '--main-disk') set -- "$@" '-m' ;;
    '--resume') set -- "$@" '-z' ;;
    '--root-size') set -- "$@" '-R' ;;
    '--swap-size') set -- "$@" '-S' ;;
    '--home-size') set -- "$@" '-H' ;;
    '--skip-wipe-disks') set -- "$@" '-x' ;;
    '--version') set -- "$@" '-y' ;;
    *) set -- "$@" "$arg" ;;
  esac
done

# Parse short option value
OPTIND=1
while getopts ":hm:b:R:S:H:xtyz" short_option; do
  case "${short_option}" in
    h)
      printHelp
      exit 0
      ;;
    m) MAIN_DISK="$(run parseMaindisk "${short_option}" "${MAIN_DISK}")" ;;
    b) BOOT_KEY="$(run parseBootkey "${short_option}" "${BOOT_KEY}")" ;;
    R)
      ROOT_SIZE="$(run parseRootSize "${short_option}" "${RAW_ROOT_SIZE}")"
      RAW_ROOT_SIZE="${OPTARG}"
      ;;
    S)
      SWAP_SIZE="$(run parseSwapSize "${short_option}" "${RAW_SWAP_SIZE}")"
      RAW_SWAP_SIZE="${OPTARG}"
      ;;
    H)
      HOME_SIZE="$(run parseHomeSize "${short_option}" "${RAW_HOME_SIZE}")"
      RAW_HOME_SIZE="${OPTARG}"
      ;;
    x) WIPE_DISKS=false ;;
    t) RUNNING_TEST=1 ;;
    y)
      printVersion
      exit 0
      ;;
    z) RESUME=true ;;
    :) error "option $(concat ', ' "-${OPTARG}" "$(toLongOption "-${OPTARG}")") requires an argument." ;;
    ?)
      case "${OPTARG}" in
        '-') INDEX=${OPTIND} ;;
        *) INDEX=$((OPTIND - 1)) ;;
      esac
      error "unknown option: $(findOptionAt "${INDEX}" "${*}")"
      ;;
  esac
done

# Raise an error if script not run by a user with root privileges
if ! isRunningUnitTest; then
  if [[ $(id -u) -ne 0 ]]; then
    echo -e "run $(basename "$0") as root, or issue the command\n"
    echo "    $(bold sudo) $(basename "$0") $*"
    exit 1
  fi
fi

# Remove parsed options from script argument list
shift $((OPTIND - 1))

if [[ "${RESUME}" == "true" ]]; then
  # Restore global options variables to their last saved state
  loadCheckPoint
  heading "********** Resuming execution              **********"
fi

# Check that required global variables are set
assert isSet "${MAIN_DISK}" \
  error "the option '-m, --main-disk' is required."
assert isSet "${BOOT_KEY}" \
  error "the option '-b, --boot-key' is required."
assert isSet "${ROOT_SIZE}" \
  error "the option '-R, --root-size' is required."
assert isSet "${SWAP_SIZE}" \
  error "the option '-S, --swap-size' is required."

# Check that we are NOT Setting up the system and the boot-key on the same disk
assert isNotMainDisk "${BOOT_KEY}" \
  error "options main-disk and boot-key refer to the same device: ${BOOT_KEY}"

MAIN_DISK_SIZE=$(blockdev --getsize64 "${MAIN_DISK}")
# Reserve 16MiB for the partition table and LVM header
METADATA=$(toBytes 16M)

if ! isSet "${HOME_SIZE}"; then
  EMPTY_SPACE=$((MAIN_DISK_SIZE - METADATA - ROOT_SIZE - SWAP_SIZE))
  EMPTY_SPACE=$(max 0 "${EMPTY_SPACE}")

  HOME_SIZE=0

  if [[ ${EMPTY_SPACE} -ne 0 ]]; then
    assert isZeroOrAtLeast4MiB "${EMPTY_SPACE}" \
      error "there is only $(byteToString "${EMPTY_SPACE}") available. Home partition size must be either 0 or at least 4MiB."

    read -r -p \
      "Would you like to allocate the remaining $(byteToString "${EMPTY_SPACE}") to the home partition? [y/N] " \
      REPLY

    # Assign remaining empty space minus a 16MiB metadata buffer to the home partition
    if [[ "${REPLY}" == y ]]; then
      HOME_SIZE=${EMPTY_SPACE}
    fi
  fi
fi

if [[ "${RESUME}" == false ]]; then
  # Warn about zero-sized partitions and ask for confirmation
  assert isNotZero "${SWAP_SIZE}" \
    confirmContinue "no space allocated for SWAP."
  assert isNotZero "${HOME_SIZE}" \
    confirmContinue "no space allocated for the home partition."

  # Check that partition sizes are consistent with total available empty space
  TOTAL_INSTALL_SIZE=$((METADATA + ROOT_SIZE + SWAP_SIZE + HOME_SIZE))

  function mainDiskCanContainPartitions { [[ $1 -le ${MAIN_DISK_SIZE} ]]; }

  assert mainDiskCanContainPartitions "${TOTAL_INSTALL_SIZE}" \
    error \
    "not enough empty space to store metadata and partitions.
       Need at least $(byteToString "${TOTAL_INSTALL_SIZE}"), but has only $(byteToString "${MAIN_DISK_SIZE}") available. Remember that 16MiB are reserved for storing metadata."

  # Ask for confirmation before destroying existing partitions on main disk and boot-key
  if ! isRunningUnitTest; then
    PARTITION_LIST="$(concat "\n" "$(listPartitions "${MAIN_DISK}")" "$(listPartitions "${BOOT_KEY}")")"

    if ! isEmpty "${PARTITION_LIST}"; then
      echo -e "Found existing data on one or both of the following devices: ${MAIN_DISK}, ${BOOT_KEY} :\n"
      for partition in ${PARTITION_LIST}; do
        printf "%s\n\n" "$(list5LargestFilesOnPartition "${partition}")"
      done
      confirmContinue "The installation process will permanently delete the device content listed above!"
    fi
  fi
fi

if [[ "${RESUME}" == false ]]; then
  # Show planned partition layout
  BOOT_KEY_SIZE=$(blockdev --getsize64 "${BOOT_KEY}")

  printSummary "${MAIN_DISK}" "${MAIN_DISK_SIZE}" "${BOOT_KEY}" "${BOOT_KEY_SIZE}" \
    "${ROOT_SIZE}" "${SWAP_SIZE}" "${HOME_SIZE}"

  countDown 5 "Starting in 5 seconds"
fi

# Stop script execution beyond this point and signal success while running
# unit-tests. Acts as a separator between pure operations and those with
# side-effects. Activated by the -t flag on the command line.
if isRunningUnitTest; then
  exit 0
fi

trap messageOnAbort EXIT

if [[ -z "${CHECKPOINT_ID}" ]]; then
  heading "Setting Up Installation Tools..."

  subheading "Checking internet connection..."
  assert hasInternetAccess "" \
    error \
    "unable to reach the internet.
       For more information about how to configure your network interface,
       please consult the NixOS manual at:
       https://nixos.org/manual/nixos/stable/#sec-installation-manual-networking"

  subheading "Installing software dependencies..."
  nix-env -iA age -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  nix-env -iA b3sum -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  nix-env -iA pv -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  saveCheckPoint tools-installed
fi
