#!/usr/bin/env bash

# Copyright (c) 2023 Nick Piaddo
# SPDX-License-Identifier: Apache-2.0 OR MIT

################################################################################
# Description
# nixos-fde-config:
#   script for configuring a NixOS system with full disk encryption.
#
#   This script creates a LUKS2 encrypted container on the given main disk,
#   then adds three ext4-formatted LVM volumes (root, swap, home).
#
#   The LUKS2 container's header-file, along with a decryption key-file are
#   added as a compressed, passphrase-protected archive to a UEFI boot partition
#   on the USB boot-key.
#
#   After a successful setup, the boot-key is required to boot the system.
#   You will also need to provide your passphrase to mount the filesystem.
#
################################################################################

# Coding convention
#
# CAPITAL_SNAKE_CASE: global variable
# snake_case: local variable
# camelCase: function

# Script template inspired by
# https://sharats.me/posts/shell-script-best-practices/
set -o errexit
set -o nounset
set -o pipefail
shopt -s globstar
shopt -s nullglob

# Run script `TRACE=1 ./nixos-fde-config [options]' to enable tracing
if [[ "${TRACE-0}" == "1" ]]; then
  set -o xtrace
fi

################################################################################
#                        GLOBAL VARIABLES
############################################################################nÏ–+o
VERSION="##version##"
REVISION="##revision##"
TMP_FILE="/root/.fde-config"
MAIN_DISK=""
BOOT_KEY=""
ROOT_SIZE=""
SWAP_SIZE=""
HOME_SIZE=""
WIPE_DISKS=true
RESUME=false
CHECKPOINT_ID=""

################################################################################
#                        HELPER FUNCTIONS
################################################################################

#### OUTPUT FORMATTING FUNCTIONS

function formatText {
  # escape character start
  local on="$1"
  # escape character end
  local off="$2"
  local text="$3"

  echo -ne "${on}${text}${off}"
}

function bold { formatText "$(tput -T ansi bold)" "$(tput -T ansi sgr0)" "$1"; }
function redbg { formatText "$(tput -T ansi setab 1)" "$(tput -T ansi sgr0)" "$1"; }
function underline { formatText "$(tput -T ansi smul)" "$(tput -T ansi rmul)" "$1"; }
function yellowbg { formatText "$(tput -T ansi setab 3)" "$(tput -T ansi sgr0)" "$1"; }

function heading { printf "%s\n" "$(bold "$1") "; }

function subheading { echo "> $1"; }

#### MAIN HELPER FUNCTIONS

######################################################################
# Print version.
# Arguments:
#   None
# Outputs:
#   Command version
######################################################################
function printVersion {
  echo "$(basename "$0") ${VERSION} ${REVISION}"
}

######################################################################
# Print usage.
# Arguments:
#   None
# Outputs:
#   Usage instructions
######################################################################
function printUsage {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0
END
}

######################################################################
# Print help page.
# Arguments:
#   None
# Outputs:
#   Usage manual
######################################################################
function printHelp {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --help

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0

   $(bold DESCRIPTION)

       $(basename "$0") is a setup script for configuring a NixOS system with
       full disk encryption.

       It creates a LUKS2 encrypted container on the given main disk, then adds
       up to three ext4-formatted LVM volumes (root, swap, home).

       The LUKS2 container's header-file, along with a decryption key-file are
       added as a compressed, passphrase-protected archive to a UEFI boot
       partition on the USB bootkey.

       After a successful setup, the bootkey is required to boot the system.
       You will also need to provide your passphrase to mount the filesystem.

       $(bold Note:) When sizing your partitions, take into account that $(bold 16MiB)
             are reserved on the main disk for GPT and LVM metadata.

   $(bold OPTIONS)

       -h, --help               Display this help and exit.
       -z, --resume             Resume execution from the last successful step
                                before interruption.
       --version                Print script version string.

       -m, --main-disk DEVPATH  Specify where to install NixOS.
       -b, --boot-key  DEVPATH  Specify where to put the boot partition.
       -R, --root-size SIZE     Specify the root partition size.
       -S, --swap-size SIZE     Specify the swap partition size.
       -H, --home-size SIZE     Specify the home partition size. (Optional)
                                (default: remaining free space after root
                                 and swap partitions)

       --skip-wipe-disks        Skip wiping disks with random data before
                                formatting.

                                Wiping a disk with random data, before creating
                                the LUKS container, helps hide the size of the
                                encrypted content and gives you plausible
                                deniability about its very existence.
                                $(bold "Use this option at your own risk!")

       Command parameters:

       DEVPATH the absolute path to a disk (e.g. /dev/sda).

       SIZE the integer partition size in bytes. Must be at least 8GiB for the
       root partition. Otherwise, either 0 or at least 4MiB.

       Optional suffixes k or K (kibibyte, 1024 bytes), M (mebibyte, 1024k),
       G (gibibyte, 1024M), and T (tebibyte, 1024G) are supported.
END
}

#### ERROR MANAGEMENT FUNCTIONS

######################################################################
# Print error message and terminate program.
# Arguments:
#   Error message
# Outputs:
#   Writes error message to stderr
# Returns:
#   Exit code 1
######################################################################
function error {
  echo -e "$(redbg Error:) $*" >&2
  exit 1
}

######################################################################
# Print recovery help message after script execution error.
# Arguments:
#   None
# Outputs:
#   A how-to-recover message on error
# Returns:
#   1
######################################################################
function messageOnAbort {
  if [[ "$?" -ne 0 ]]; then
    cat <<END

$(redbg "An error occurred during execution. Aborting...")
After resolving the issue, you can resume execution with the command:

    $(basename "$0") --resume

END
    return 1
  fi
}

#### CONVERSION FUNCTIONS

######################################################################
# Convert a short option to its long version.
# Arguments:
#   Short option
# Returns:
#   Long version of the given short option
#   Empty string otherwise
######################################################################
function toLongOption {
  local short_option="$1"

  case "${short_option}" in
    '-h') echo '--help' ;;
    '-y') echo '--version' ;;
    '-z') echo '--resume' ;;
    *) echo "" ;;
  esac
}

#### UTILITY FUNCTIONS

######################################################################
# Concatenate two strings separated by the given separator character
# if the two strings are non-empty. Returns an empty string or whichever
# of the two is non-empty otherwise.
#
# Examples:
#
#   concat ';' '' ''       --> ''
#   concat ';' '' 'bar'    --> 'bar'
#   concat ';' 'foo' ''    --> 'foo'
#   concat ';' 'foo' 'bar' --> 'foo;bar'
#
# Arguments:
#   Separator character
#   First string
#   Second string
# Returns:
#   Concatenated strings
######################################################################
function concat {
  # No argument or just the separator
  if [[ $# -eq 0 || $# -eq 1 ]]; then
    echo ""
  # Separator + one string
  elif [[ $# -eq 2 ]]; then
    echo -e "$2"
  # Separator + two strings
  else
    local separator="$1"
    local first="$2"
    local second="$3"

    # concat ';' '' ''
    if [[ -z "${first}" && -z "${second}" ]]; then
      echo ""
    # concat ';' '' 'bar'
    elif [[ -z "${first}" && -n "${second}" ]]; then
      echo -e "${second}"
    # concat ';' 'foo' ''
    elif [[ -n "${first}" && -z "${second}" ]]; then
      echo -e "${first}"
    # concat ';' 'foo' 'bar'
    else
      echo -e "${first}${separator}${second}"
    fi
  fi
}

######################################################################
# Find the option at the given index in the string.
# Arguments:
#   Index
#   String
# Returns:
#   First option at index
#   Empty string if there is none
######################################################################
function findOptionAt {
  local index="$1"
  local argument_list="$2"
  echo "${argument_list}" | cut --delimiter=' ' --fields="${index}"
}

#### STATE MANAGEMENT FUNCTIONS

######################################################################
# Load saved global options variables from disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   None
# Returns:
#   Options variables set to their last saved state
######################################################################
function loadCheckPoint {
  read -r MAIN_DISK BOOT_KEY ROOT_SIZE SWAP_SIZE \
    HOME_SIZE WIPE_DISKS CHECKPOINT_ID <<<"$(<${TMP_FILE})"
}

######################################################################
# Save global options variables to disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   Check point identifier
# Outputs:
#  Global options variables to disk
######################################################################
function saveCheckPoint {
  CHECKPOINT_ID="$1"
  echo -n "${MAIN_DISK} ${BOOT_KEY} ${ROOT_SIZE} ${SWAP_SIZE} \
    ${HOME_SIZE} ${WIPE_DISKS} ${CHECKPOINT_ID}" >|"${TMP_FILE}"
}

################################################################################
#                        MAIN PROGRAM
################################################################################

if [[ $# -eq 0 ]]; then
  printUsage
  exit 1
fi

# From https://stackoverflow.com/a/30026641
# Long option to short option substitution
for arg in "$@"; do
  shift
  case "$arg" in
    '--help') set -- "$@" '-h' ;;
    '--resume') set -- "$@" '-z' ;;
    '--version') set -- "$@" '-y' ;;
    *) set -- "$@" "$arg" ;;
  esac
done

# Parse short option value
OPTIND=1
while getopts ":hyz" short_option; do
  case "${short_option}" in
    h)
      printHelp
      exit 0
      ;;
    y)
      printVersion
      exit 0
      ;;
    z) RESUME=true ;;
    :) error "option $(concat ', ' "-${OPTARG}" "$(toLongOption "-${OPTARG}")") requires an argument." ;;
    ?)
      case "${OPTARG}" in
        '-') INDEX=${OPTIND} ;;
        *) INDEX=$((OPTIND - 1)) ;;
      esac
      error "unknown option: $(findOptionAt "${INDEX}" "${*}")"
      ;;
  esac
done

# Remove parsed options from script argument list
shift $((OPTIND - 1))

if [[ "${RESUME}" == "true" ]]; then
  # Restore global options variables to their last saved state
  loadCheckPoint
  heading "********** Resuming execution              **********"
fi

trap messageOnAbort EXIT
