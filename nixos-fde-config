#!/usr/bin/env bash

# Copyright (c) 2023 Nick Piaddo
# SPDX-License-Identifier: Apache-2.0 OR MIT

################################################################################
# Description
# nixos-fde-config:
#   script for configuring a NixOS system with full disk encryption.
#
#   This script creates a LUKS2 encrypted container on the given main disk,
#   then adds three ext4-formatted LVM volumes (root, swap, home).
#
#   The LUKS2 container's header-file, along with a decryption key-file are
#   added as a compressed, passphrase-protected archive to a UEFI boot partition
#   on the USB boot-key.
#
#   After a successful setup, the boot-key is required to boot the system.
#   You will also need to provide your passphrase to mount the filesystem.
#
################################################################################

# Coding convention
#
# CAPITAL_SNAKE_CASE: global variable
# snake_case: local variable
# camelCase: function

# Script template inspired by
# https://sharats.me/posts/shell-script-best-practices/
set -o errexit
set -o nounset
set -o pipefail
shopt -s globstar
shopt -s nullglob

# Run script `TRACE=1 ./nixos-fde-config [options]' to enable tracing
if [[ "${TRACE-0}" == "1" ]]; then
  set -o xtrace
fi

################################################################################
#                        GLOBAL VARIABLES
############################################################################nϖ+o
VERSION="##version##"
REVISION="##revision##"
TMP_FILE="/root/.fde-config"
MAIN_DISK=""
BOOT_KEY=""
RAW_ROOT_SIZE=""
ROOT_SIZE=""
RAW_SWAP_SIZE=""
SWAP_SIZE=""
RAW_HOME_SIZE=""
HOME_SIZE=""
WIPE_DISKS=true
RESUME=false
CHECKPOINT_ID=""
RUNNING_TEST=0

################################################################################
#                        HELPER FUNCTIONS
################################################################################

#### OUTPUT FORMATTING FUNCTIONS

function formatText {
  # escape character start
  local on="$1"
  # escape character end
  local off="$2"
  local text="$3"

  echo -ne "${on}${text}${off}"
}

function bold { formatText "$(tput -T ansi bold)" "$(tput -T ansi sgr0)" "$1"; }
function redbg { formatText "$(tput -T ansi setab 1)" "$(tput -T ansi sgr0)" "$1"; }
function underline { formatText "$(tput -T ansi smul)" "$(tput -T ansi rmul)" "$1"; }
function yellowbg { formatText "$(tput -T ansi setab 3)" "$(tput -T ansi sgr0)" "$1"; }

function heading { printf "%s\n" "$(bold "$1") "; }

function subheading { echo "> $1"; }

#### MAIN HELPER FUNCTIONS

######################################################################
# Print version.
# Arguments:
#   None
# Outputs:
#   Command version
######################################################################
function printVersion {
  echo "$(basename "$0") ${VERSION} ${REVISION}"
}

######################################################################
# Print usage.
# Arguments:
#   None
# Outputs:
#   Usage instructions
######################################################################
function printUsage {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --save-hash DEVPATH

       $(basename "$0") --help

       $(basename "$0") --reset

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0
END
}

######################################################################
# Print help page.
# Arguments:
#   None
# Outputs:
#   Usage manual
######################################################################
function printHelp {
  cat <<-END
   $(bold USAGE)

       $(basename "$0") -m DEVPATH -b DEVPATH -R SIZE -S SIZE [-H SIZE]
                        [--skip-wipe-disks]

       $(basename "$0") --save-hash DEVPATH

       $(basename "$0") --help

       $(basename "$0") --reset

       $(basename "$0") --resume

       $(basename "$0") --version

   $(bold EXAMPLES)

       Configure a system with a bootkey at /dev/sdb, a main disk at /dev/sda
       with a 16G root partition, 8G of swap, and a 64G /home partition.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 64G

       By default, not specifying the size of the home partition will allocate
       all remaining free space to it. In the example below, the home partition
       will have size home_size = disk_size - (root_size + swap_size).

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G

       If you do not want a dedicated partition for the /home directory, set
       its size to zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 8G -H 0

      Equally, if you want a system without a swap partition set its value to
      zero.

           $(bold "$(basename "$0")") -b /dev/sdb -m /dev/sda -R 16G -S 0 -H 0

   $(bold DESCRIPTION)

       $(basename "$0") is a setup script for configuring a NixOS system with
       full disk encryption.

       It creates a LUKS2 encrypted container on the given main disk, then adds
       up to three ext4-formatted LVM volumes (root, swap, home).

       The LUKS2 container's header-file, along with a decryption key-file are
       added as a compressed, passphrase-protected archive to a UEFI boot
       partition on the USB bootkey.

       After a successful setup, the bootkey is required to boot the system.
       You will also need to provide your passphrase to mount the filesystem.

       $(bold Note:) When sizing your partitions, take into account that $(bold 16MiB)
             are reserved on the main disk for GPT and LVM metadata.

   $(bold OPTIONS)

       -h, --help               Display this help and exit.
       -z, --resume             Resume execution from the last successful step
                                before interruption.
       --reset                  Revert main disk to a safe state before script
                                re-execution.
       --version                Print script version string.

       -m, --main-disk DEVPATH  Specify where to install NixOS.
       -b, --boot-key  DEVPATH  Specify where to put the boot partition.
       -R, --root-size SIZE     Specify the root partition size.
       -S, --swap-size SIZE     Specify the swap partition size.
       -H, --home-size SIZE     Specify the home partition size. (Optional)
                                (default: remaining free space after root
                                 and swap partitions)

       --save-hash DEVPATH      Compute and save a checksum of the bootkey in
                                fde-configuration.nix

       --skip-wipe-disks        Skip wiping disks with random data before
                                formatting.

                                Wiping a disk with random data, before creating
                                the LUKS container, helps hide the size of the
                                encrypted content and gives you plausible
                                deniability about its very existence.
                                $(bold "Use this option at your own risk!")

       Command parameters:

       DEVPATH the absolute path to a disk (e.g. /dev/sda).

       SIZE the integer partition size in bytes. Must be at least 8GiB for the
       root partition. Otherwise, either 0 or at least 4MiB.

       Optional suffixes k or K (kibibyte, 1024 bytes), M (mebibyte, 1024k),
       G (gibibyte, 1024M), and T (tebibyte, 1024G) are supported.
END
}

#### ERROR MANAGEMENT FUNCTIONS

######################################################################
# Print error message and terminate program.
# Arguments:
#   Error message
# Outputs:
#   Writes error message to stderr
# Returns:
#   Exit code 1
######################################################################
function error {
  echo -e "$(redbg Error:) $*" >&2
  exit 1
}

######################################################################
# Print recovery help message after script execution error.
# Arguments:
#   None
# Outputs:
#   A how-to-recover message on error
# Returns:
#   1
######################################################################
function messageOnAbort {
  if [[ "$?" -ne 0 ]]; then
    cat <<END

$(redbg "An error occurred during execution. Aborting...")
After resolving the issue, you can resume execution with the command:

    $(basename "$0") --resume

If the problem persists, try resetting to a safe state with the command:

    $(basename "$0") --reset

Then start over.
END
    return 1
  fi
}

######################################################################
# Execute an error function if a predicate function returns false.
# Arguments:
#   Predicate function
#   Argument of the predicate function
#   Error function to execute if assertion is false
#   Error message
# Outputs:
#   Nothing if the predicate is true. The error function's output
#   otherwise.
######################################################################
function assert {
  local pred_fun="$1"
  local pred_arg="$2"
  local error_fun="$3"
  local error_arg="$4"

  if ! $pred_fun "${pred_arg}"; then
    $error_fun "${error_arg}"
  fi
}

######################################################################
# Print warning message.
# Arguments:
#   Warning message
# Outputs:
#   Writes warning message to stderr
######################################################################
function warn {
  echo -e "$(yellowbg WARNING:) $1" >&2
}

######################################################################
# Ask for confirmation after a warning.
# Arguments:
#  Warning message
# Outputs:
#   Writes warning to stderr
# Returns:
#   0 if action is confirmed, non-zero otherwise
######################################################################
function confirmContinue {
  local message="$1"
  local reply

  warn "${message}"
  read -r -p "Would you like to continue? [y/N] " reply

  if [[ "${reply}" != y ]]; then
    exit 1
  fi
}

######################################################################
# Executes a statement and suppresses its exit status
# Arguments:
#   A bash expression
# Returns:
#   0
######################################################################
function ignoreExitStatus { if ! ("$@"); then return 0; fi; }

#### CONVERSION FUNCTIONS

######################################################################
# Convert a short option to its long version.
# Arguments:
#   Short option
# Returns:
#   Long version of the given short option
#   Empty string otherwise
######################################################################
function toLongOption {
  local short_option="$1"

  case "${short_option}" in
    '-h') echo '--help' ;;
    '-y') echo '--version' ;;
    '-z') echo '--resume' ;;
    '-r') echo '--reset' ;;
    '-a') echo '--save-hash' ;;
    '-m') echo '--main-disk' ;;
    '-b') echo '--boot-key' ;;
    '-R') echo '--root-size' ;;
    '-S') echo '--swap-size' ;;
    '-H') echo '--home-size' ;;
    '-x') echo '--skip-wipe-disks' ;;
    *) echo "" ;;
  esac
}

######################################################################
# Extract integer prefix from a string.
# Arguments:
#   A string starting with an integer
# Returns:
#   The integer prefix of the string
#   An empty string  if there is no prefix
######################################################################
function parseIntPrefix {
  local string="$1"

  if [[ "${string}" =~ ^[0-9]+ ]]; then
    echo "${BASH_REMATCH[0]}"
  fi
}

######################################################################
# Convert a size denomination to its equivalent in bytes.
# Arguments:
#   Size with optional unit
# Returns:
#   Size in bytes
######################################################################
function toBytes {
  local size="$1"

  local one_KiB=1024
  local one_MiB=$((1024 * one_KiB))
  local one_GiB=$((1024 * one_MiB))
  local one_TiB=$((1024 * one_GiB))

  local size_in_bytes

  # Kibibytes
  if [[ "${size}" = *[kK] ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_KiB))
  # Mebibytes
  elif [[ "${size}" = *M ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_MiB))
  # Gibibytes
  elif [[ "${size}" = *G ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_GiB))
  # Tebibytes
  elif [[ "${size}" = *T ]]; then
    size_in_bytes=$(parseIntPrefix "${size}")
    size_in_bytes=$((size_in_bytes * one_TiB))
  # Bytes
  else
    size_in_bytes=${size}
  fi

  echo "${size_in_bytes}"
}

#### UTILITY FUNCTIONS

######################################################################
# Concatenate two strings separated by the given separator character
# if the two strings are non-empty. Returns an empty string or whichever
# of the two is non-empty otherwise.
#
# Examples:
#
#   concat ';' '' ''       --> ''
#   concat ';' '' 'bar'    --> 'bar'
#   concat ';' 'foo' ''    --> 'foo'
#   concat ';' 'foo' 'bar' --> 'foo;bar'
#
# Arguments:
#   Separator character
#   First string
#   Second string
# Returns:
#   Concatenated strings
######################################################################
function concat {
  # No argument or just the separator
  if [[ $# -eq 0 || $# -eq 1 ]]; then
    echo ""
  # Separator + one string
  elif [[ $# -eq 2 ]]; then
    echo -e "$2"
  # Separator + two strings
  else
    local separator="$1"
    local first="$2"
    local second="$3"

    # concat ';' '' ''
    if [[ -z "${first}" && -z "${second}" ]]; then
      echo ""
    # concat ';' '' 'bar'
    elif [[ -z "${first}" && -n "${second}" ]]; then
      echo -e "${second}"
    # concat ';' 'foo' ''
    elif [[ -n "${first}" && -z "${second}" ]]; then
      echo -e "${first}"
    # concat ';' 'foo' 'bar'
    else
      echo -e "${first}${separator}${second}"
    fi
  fi
}

######################################################################
# Find the option at the given index in the string.
# Arguments:
#   Index
#   String
# Returns:
#   First option at index
#   Empty string if there is none
######################################################################
function findOptionAt {
  local index="$1"
  local argument_list="$2"
  echo "${argument_list}" | cut --delimiter=' ' --fields="${index}"
}

######################################################################
# Find a device mount points.
# Arguments:
#   Device path
# Returns:
#   A list of mount points
#   Empty string if there are none
######################################################################
function findMountPoints {
  local device="$1"
  lsblk --noheadings --list --output MOUNTPOINTS "${device}" \
    | sed '/^\s*$/d' \
    | tr "\n" " " \
    | sed 's/\s*$//'
}

######################################################################
# Divide two integers, then truncate the result after the first
# non-zero decimal digit
# Arguments:
#   Numerator
#   Denominator
# Returns:
#   The ratio of numerator to denominator truncated after
#   the first non-zero decimal digit
######################################################################
function truncDivide {
  local numerator="$1"
  local denominator="$2"

  local ratio
  ratio=$(awk "BEGIN {print ${numerator} / ${denominator}}")
  if isInteger "${ratio}"; then
    echo "${ratio}"
  else
    local integer_part
    local fractional_part
    local index_first_non_zero=0

    integer_part=$(echo "${ratio}" | cut -d'.' -f1)
    fractional_part=$(echo "${ratio}" | cut -d'.' -f2)

    for ((i = 0; i < ${#fractional_part}; i++)); do
      if [[ "${fractional_part:$i:1}" != "0" ]]; then
        index_first_non_zero=$i
        break
      fi
    done

    local end=$((index_first_non_zero + 1))
    echo "${integer_part}.${fractional_part:0:$end}"
  fi

}

######################################################################
# Convert size in bytes to their closest unit multiple.
# Arguments:
#   An integer
# Returns:
#   The size with its appropriate unit (KiB, MiB,...)
######################################################################
function byteToString {
  local size_in_bytes="$1"

  local one_KiB=1024
  local metric_prefix="KMGTPEZYRQ"

  local power
  local unit
  local ratio

  if [[ ${size_in_bytes} -lt ${one_KiB} ]]; then
    unit="b"
    ratio=${size_in_bytes}
  else
    power=$(awk "BEGIN { print int(log(${size_in_bytes}) / log(${one_KiB})) }")
    unit="$(printf "%s%s" "${metric_prefix:((power - 1)):1}" "iB")"
    ratio=$(truncDivide "${size_in_bytes}" "$((one_KiB ** power))")
  fi

  echo "${ratio}${unit}"
}

######################################################################
# Largest of two integers.
# Arguments:
#   First integer
#   Second integer
# Returns:
#   Largest integer value
######################################################################
function max {
  local first="$1"
  local second="$2"

  if [[ "${first}" -gt "${second}" ]]; then
    echo "${first}"
  else
    echo "${second}"
  fi
}

######################################################################
# List partitions on device.
# Arguments:
#   Absolute device path
# Returns:
#   A list of device partitions
#   Empty string, if there are none
######################################################################
function listPartitions {
  local device="$1"

  for part_num in $(parted -m "${device}" print 2>/dev/null \
    | grep -P "^[0-9]+:" | cut -d ':' -f 1); do
    echo "${device}${part_num}"
  done
}

######################################################################
# List the files on a partition ordered by decreasing order of size.
# Arguments:
#   File system type
#   Partition
# Returns:
#   A list of the n largest files on the partition
#   Empty string, if there are none
######################################################################
function listFilesOnPartition {
  local fs_type="$1"
  local partition="$2"
  local files

  if [[ -z "${fs_type}" ]]; then
    files="no file system"
  else
    local mount_point
    mount_point="$(lsblk --list --noheadings --output MOUNTPOINTS "${partition}")"

    # Partition NOT mounted
    if [[ -z "${mount_point}" ]]; then
      # Mount partition (read only)
      local tmp_dir
      tmp_dir="$(mktemp --directory --tmpdir=/tmp tmp-mount.XXXXXXXXXX)"
      mount --types "${fs_type}" --options noatime,noexec,ro "${partition}" "${tmp_dir}"

      # List files
      files="$(find "${tmp_dir}" -type f -exec ls -lSh {} + 2>/dev/null \
        | sed "s_""${tmp_dir}/""__")"

      if [[ -z "${files}" ]]; then
        files="no files"
      fi

      # Unmount partition
      umount "${tmp_dir}" 2>/dev/null
      rmdir "${tmp_dir}"
    else
      files="$(find "${mount_point}" -type f -exec ls -lSh {} + 2>/dev/null)"
    fi
  fi

  echo "${files}"
}

######################################################################
# List the N largest files on a partition.
# Arguments:
#   Maximum number of files
#   Device partition
# Returns:
#   A list of the n largest files on the partition
#   Empty string, if there are none
######################################################################
function listNLargestFilesOnPartition {
  local limit="$1"
  local partition="$2"

  local part_info
  local part_type
  local fs_type
  local files
  local nb_lines

  part_info="$(lsblk --list --noheadings --output TYPE,FSTYPE "${partition}" -- 2>/dev/null)"
  part_type="$(echo "${part_info}" | awk '{print $1}')"
  fs_type="$(echo "${part_info}" | awk '{print $2}')"

  case "${part_type}" in
    'crypt') files="*** encrypted ***" ;;
    *) files="$(listFilesOnPartition "${fs_type}" "${partition}")" ;;
  esac

  printf "%s:\n%s\n" "$(bold "${partition}")" "$(echo "${files}" | head --lines="${limit}")"

  nb_lines=$(echo "${files}" | wc --lines)

  if [[ ${nb_lines} -gt ${limit} ]]; then
    printf "... truncated ...\n\n"
  fi
}

function list5LargestFilesOnPartition { listNLargestFilesOnPartition 5 "$1"; }

######################################################################
# Print summary of partition structure.
# Arguments:
#   Main disk path
#   Main disk size
#   Boot key path
#   Boot key size
#   Root partition size
#   Swap partition size
#   Homw partition size
# Outputs:
#   Summary of partition structure
######################################################################
function printSummary {
  local main_disk="$1"
  local main_disk_size="$2"
  local boot_key="$3"
  local boot_key_size="$4"
  local root_size="$5"
  local swap_size="$6"
  local home_size="$7"

  main_disk_size="$(byteToString "${main_disk_size}")"
  boot_key_size="$(byteToString "${boot_key_size}")"

  main_disk="$(basename "${main_disk}")"
  boot_key="$(basename "${boot_key}")"

  root_size="$(byteToString "${root_size}")"
  swap_size="$(byteToString "${swap_size}")"
  home_size="$(byteToString "${home_size}")"

  printf "\nCreating a NixOS system with the following partition layout:\n\n"
  printf "%s\n" "$(bold "main disk:")"
  printf "  %-19s  %8s   %s\n" "NAME" "SIZE" "TYPE"
  printf "  %-19s  %8s   %s\n" "${main_disk}" "${main_disk_size}" "disk"
  printf "  %-23s  %8s   %s\n" "└─lukscontainer" "${main_disk_size}" "crypt"

  # No home or swap partitions
  if [[ ${SWAP_SIZE} -eq 0 && ${HOME_SIZE} -eq 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  └─-root" "${root_size}" "lvm"
  # One of or both home and swap partitions
  else
    printf "  %-23s  %8s   %s\n" "  ├─-root" "${root_size}" "lvm"
  fi

  # Only a swap partitions
  if [[ ${SWAP_SIZE} -gt 0 && ${HOME_SIZE} -eq 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  └─-swap" "${swap_size}" "lvm"
  # Both home and swap partitions
  elif [[ ${SWAP_SIZE} -gt 0 && ${HOME_SIZE} -gt 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  ├─-swap" "${swap_size}" "lvm"
  fi

  if [[ ${HOME_SIZE} -gt 0 ]]; then
    printf "  %-23s  %8s   %s\n" "  └─-home" "${home_size}" "lvm"
  fi

  printf "\n"
  printf "%s\n" "$(bold "bootkey:")"
  printf "  %-19s  %8s   %s\n" "NAME" "SIZE" "TYPE"
  printf "  %-19s  %8s   %s\n" "${boot_key}" "${boot_key_size}" "disk"
  printf "  %-23s  %8s   %s\n" "└─${boot_key}1" "2GiB" "part"
  printf "\n"
}

######################################################################
# Print a message and count down for n seconds.
# Arguments:
#   Duration
#   Message
# Outputs:
#   Message
######################################################################
function countDown {
  local duration="$1"
  local message="$2"

  echo -n "${message}"

  for i in $(seq "${duration}"); do
    echo -n "."
    sleep 1
  done
  echo ""
}

######################################################################
# Executes a statement and suppresses its output
# Arguments:
#   A bash expression
# Returns:
#   Expression's exit status
######################################################################
function quiet { "$@" >/dev/null 2>&1; }

######################################################################
# Fill device with random data
# Arguments:
#   Device path
# Returns:
#   0 when device is filled, non-zero on error
######################################################################
function fillWithRandomData {
  local device="$1"
  local size_in_bytes
  size_in_bytes=$(blockdev --getsize64 "${device}")

  pv --size "${size_in_bytes}" --stop-at-size </dev/urandom >"${device}"
}

######################################################################
# Find a disk's World Wide IDentificator (WWID)
# Arguments:
#   Device path
# Returns:
#   Device WWID if it exists, empty string otherwise
######################################################################
function findWWID {
  local devicePath="$1"
  local path

  for device in /dev/disk/by-id/*; do
    path="$(realpath "${device}")"
    if [[ "${path}" == "${devicePath}" ]]; then
      basename "${device}"
      break
    fi
  done
}

#### STATE MANAGEMENT FUNCTIONS

######################################################################
# Load saved global options variables from disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   None
# Returns:
#   Options variables set to their last saved state
######################################################################
function loadCheckPoint {
  read -r MAIN_DISK BOOT_KEY ROOT_SIZE SWAP_SIZE \
    HOME_SIZE WIPE_DISKS CHECKPOINT_ID <<<"$(<${TMP_FILE})"
}

######################################################################
# Save global options variables to disk.
# Globals:
#   MAIN_DISK
#   BOOT_KEY
#   ROOT_SIZE
#   SWAP_SIZE
#   HOME_SIZE
#   WIPE_DISKS
#   CHECKPOINT_ID
# Arguments:
#   Check point identifier
# Outputs:
#  Global options variables to disk
######################################################################
function saveCheckPoint {
  CHECKPOINT_ID="$1"
  echo -n "${MAIN_DISK} ${BOOT_KEY} ${ROOT_SIZE} ${SWAP_SIZE} \
    ${HOME_SIZE} ${WIPE_DISKS} ${CHECKPOINT_ID}" >|"${TMP_FILE}"
}

######################################################################
# Revert main disk to a safe state before script re-execution..
# Arguments:
#  None
# Returns:
#  Zero
######################################################################
function deleteInstallationArtefacts {
  heading "Removing installation artefacts..."

  # Clean up possible artefacts from a previous failed run
  subheading "Deactivating SWAP partition..."
  quiet ignoreExitStatus swapoff /dev/mapper/vg_nixos-swap

  subheading "Unmounting partitions..."
  quiet ignoreExitStatus umount -R -q -f /mnt # Unmount root and home partitions

  subheading "Deactivating LVM logical volumes..."
  quiet ignoreExitStatus lvchange --activate n --force vg_nixos

  subheading "Closing LUKS container..."
  quiet ignoreExitStatus dmsetup remove_all

  # Delete LUKS2 header amd key files
  subheading "Deleting secrets..."
  quiet ignoreExitStatus umount -R -q -f /root/secrets
  quiet ignoreExitStatus rm -rf /root/secrets

  heading "Done."
}

#### PREDICATE FUNCTIONS

######################################################################
# Test if unit tests are being run.
# Arguments:
#   None
# Returns:
#   True if unit tests are running
#   False otherwise
######################################################################
function isRunningUnitTest { [[ ${RUNNING_TEST} -eq 1 ]]; }

######################################################################
# Test if a device is a block device.
# Arguments:
#   Device path
# Returns:
#   True if the device is a block device
#   False otherwise
######################################################################
function isBlockDevice { [[ -b "$1" ]]; }

######################################################################
# Test if the size of a device is at least n bytes.
# Arguments:
#   Minimum size in bytes
#   Device path
# Returns:
#   True if the size of a device is at least n bytes
#   False otherwise
######################################################################
function hasDeviceAtLeastNBytes {
  local minimum="$1"
  local device="$2"

  local size
  size=$(blockdev --getsize64 "${device}")

  [[ ${size} -ge ${minimum} ]]
}

function hasDeviceAtLeast2GiB { hasDeviceAtLeastNBytes "$(toBytes 2G)" "$1"; }
function hasDeviceAtLeast16GiB { hasDeviceAtLeastNBytes "$(toBytes 16G)" "$1"; }

######################################################################
# Test if a device is NOT mounted.
# Arguments:
#   Device path
# Returns:
#   True if the device NOT mounted
#   False otherwise
######################################################################
function isNotMounted {
  local device="$1"

  local mount_points
  mount_points="$(lsblk --list --noheadings --output MOUNTPOINTS "${device}")"
  [[ -z "${mount_points}" ]]
}

######################################################################
# Test if a variable is set.
# Arguments:
#   Variable value
# Returns:
#   True if variable is set
#   False otherwise
######################################################################
function isSet { [[ -n "$1" ]]; }

######################################################################
# Test if a device path is not identical to the main disk's.
# Arguments:
#   Device path
# Returns:
#   True device paths differ
#   False otherwise
######################################################################
function isNotMainDisk { [[ "${MAIN_DISK}" != "$1" ]]; }

######################################################################
# Test if the size is at least as large as the given lower limit.
# Arguments:
#   Lower limit in bytes
#   Size in bytes
# Returns:
#   True if the size is greater than or equal to a lower limit
#   False otherwise
######################################################################
function isAtLeastNBytes {
  local lower_limit="$1"
  local size_in_bytes="$2"

  [[ ${size_in_bytes} -ge ${lower_limit} ]]
}

function isAtLeast8GiB { isAtLeastNBytes "$(toBytes 8G)" "$1"; }

######################################################################
# Test if an expression of size is well formed.
# Arguments:
#   Size in with optional unit
# Returns:
#   True if the size is well formed
#   False otherwise
######################################################################
function isValidSize { [[ "$1" =~ (^[0-9]+$)|(^[0-9]+[kKMGT]$) ]]; }

######################################################################
# Test if a disk size in bytes is zero or at least 4MiB
# Arguments:
#   Size in bytes
# Returns:
#   True if the size is zero or 4MiB
#   False otherwise
######################################################################
function isZeroOrAtLeast4MiB { [[ $1 -eq 0 || $1 -ge $(toBytes 4M) ]]; }

######################################################################
# Test if an integer is not zero
# Arguments:
#   Integer value
# Returns:
#   True if an integer is not equal to zero
#   False otherwise
######################################################################
function isNotZero { [[ "$1" -ne 0 ]]; }

######################################################################
# Test if a number is an integer
# Arguments:
#   Number
# Returns:
#   True if the number an integer
#   False otherwise
######################################################################
function isInteger { [[ "$1" =~ ^[0-9]+$ ]]; }

######################################################################
# Test if the length of a string is zero.
# Arguments:
#   String
# Returns:
#   True if the string has length zero
#   False otherwise
######################################################################
function isEmpty { [[ -z "$1" ]]; }

######################################################################
# Test if the machine the script is running on is connected to the
# internet
# Arguments:
#   None
# Returns:
#   True if there is an active internet connection
#   False otherwise
######################################################################
function hasInternetAccess {
  ping -qc 3 www.google.com >/dev/null 2>&1
}

#### PARSER FUNCTIONS

######################################################################
# Run a parser on a command line option value.
# Globals:
#   OPTARG
# Arguments:
#   Parser function
#   Command line option (short form)
#   Previous raw option value
# Outputs:
#  An error if the option was redefined with a conflicting value.
# Returns:
#   A parsed option value.
######################################################################
function run {
  local parserFunction="$1"
  local short_option="$2"
  local prev_value="$3"

  case "${prev_value}" in
    "" | "${OPTARG}") $parserFunction "${OPTARG}" ;;
    *) error "option $(concat ', ' "-${short_option}" "$(toLongOption "-${short_option}")") redefined with conflicting values: '${prev_value}' vs '${OPTARG}'" ;;
  esac
}

######################################################################
# Parse main-disk option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseMaindisk {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume

If the problem persists, try resetting to a safe state with the command:

  $(basename "$0") --reset

Then start over."
  assert hasDeviceAtLeast16GiB "${device_path}" \
    error "'${device_path}' must have at least 16GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse boot-key option value.
# Arguments:
#   Device path
# Returns:
#   Normalized device path, if the device meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseBootkey {
  local device_path="$1"

  assert isBlockDevice "${device_path}" \
    error "'${device_path}' is not a disk."
  assert isNotMounted "${device_path}" \
    error "'${device_path}' is currently mounted on mount point(s): $(findMountPoints "${device_path}") . \
Please unmount them all and start again.
If you see this message after a failed run, try the command:

  $(basename "$0") --resume

If the problem persists, try resetting to a safe state with the command:

  $(basename "$0") --reset

Then start over."
  assert hasDeviceAtLeast2GiB "${device_path}" \
    error "'${device_path}' must have at least 2GiB available."

  realpath "${device_path}"
}

######################################################################
# Parse root-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseRootSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isAtLeast8GiB "${size_in_bytes}" \
    error "A root partition must have at least 8GiB available. Please allocate more space."

  echo "${size_in_bytes}"
}

######################################################################
# Parse swap-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseSwapSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isZeroOrAtLeast4MiB "${size_in_bytes}" \
    error "Swap size must be either 0 or at least 4MiB."

  echo "${size_in_bytes}"
}

######################################################################
# Parse home-size option value.
# Arguments:
#   Partition size
# Returns:
#   Size in bytes, if the partition size meets minimum requirements
#   Exit code 1, otherwise
# Outputs:
#   Error message if minimum requirements are not met
######################################################################
function parseHomeSize {
  local size="$1"
  local size_in_bytes

  assert isValidSize "${size}" \
    error "Specified invalid partition size: ${size}."

  size_in_bytes=$(toBytes "${size}")
  assert isZeroOrAtLeast4MiB "${size_in_bytes}" \
    error "Home partition size must be either 0 or at least 4MiB."

  echo "${size_in_bytes}"
}

################################################################################
#                        MAIN PROGRAM
################################################################################

if [[ $# -eq 0 ]]; then
  printUsage
  exit 1
fi

# From https://stackoverflow.com/a/30026641
# Long option to short option substitution
for arg in "$@"; do
  shift
  case "$arg" in
    '--help') set -- "$@" '-h' ;;
    '--boot-key') set -- "$@" '-b' ;;
    '--main-disk') set -- "$@" '-m' ;;
    '--resume') set -- "$@" '-z' ;;
    '--reset') set -- "$@" '-r' ;;
    '--root-size') set -- "$@" '-R' ;;
    '--save-hash') set -- "$@" '-a' ;;
    '--swap-size') set -- "$@" '-S' ;;
    '--home-size') set -- "$@" '-H' ;;
    '--skip-wipe-disks') set -- "$@" '-x' ;;
    '--version') set -- "$@" '-y' ;;
    *) set -- "$@" "$arg" ;;
  esac
done

# Parse short option value
OPTIND=1
while getopts ":hm:b:a:R:S:H:xtyzr" short_option; do
  case "${short_option}" in
    h)
      printHelp
      exit 0
      ;;
    m) MAIN_DISK="$(run parseMaindisk "${short_option}" "${MAIN_DISK}")" ;;
    b) BOOT_KEY="$(run parseBootkey "${short_option}" "${BOOT_KEY}")" ;;
    R)
      ROOT_SIZE="$(run parseRootSize "${short_option}" "${RAW_ROOT_SIZE}")"
      RAW_ROOT_SIZE="${OPTARG}"
      ;;
    S)
      SWAP_SIZE="$(run parseSwapSize "${short_option}" "${RAW_SWAP_SIZE}")"
      RAW_SWAP_SIZE="${OPTARG}"
      ;;
    H)
      HOME_SIZE="$(run parseHomeSize "${short_option}" "${RAW_HOME_SIZE}")"
      RAW_HOME_SIZE="${OPTARG}"
      ;;
    x) WIPE_DISKS=false ;;
    t) RUNNING_TEST=1 ;;
    a)
      assert isBlockDevice "${OPTARG}" \
        error "'${OPTARG}' is not a disk."
      HASH="$(b3sum --no-names "${OPTARG}")"
      awk -i inplace \
        -v hash="${HASH}" \
        '{ sub(/hash = "(.*)"/, "hash = \"" hash "\""); print }' \
        /mnt/etc/nixos/fde-configuration.nix
      exit 0
      ;;
    y)
      printVersion
      exit 0
      ;;
    z) RESUME=true ;;
    r)
      deleteInstallationArtefacts
      exit 0
      ;;
    :) error "option $(concat ', ' "-${OPTARG}" "$(toLongOption "-${OPTARG}")") requires an argument." ;;
    ?)
      case "${OPTARG}" in
        '-') INDEX=${OPTIND} ;;
        *) INDEX=$((OPTIND - 1)) ;;
      esac
      error "unknown option: $(findOptionAt "${INDEX}" "${*}")"
      ;;
  esac
done

# Raise an error if script not run by a user with root privileges
if ! isRunningUnitTest; then
  if [[ $(id -u) -ne 0 ]]; then
    echo -e "run $(basename "$0") as root, or issue the command\n"
    echo "    $(bold sudo) $(basename "$0") $*"
    exit 1
  fi
fi

# Remove parsed options from script argument list
shift $((OPTIND - 1))

if [[ "${RESUME}" == "true" ]]; then
  # Restore global options variables to their last saved state
  loadCheckPoint
  heading "********** Resuming execution              **********"
fi

# Check that required global variables are set
assert isSet "${MAIN_DISK}" \
  error "the option '-m, --main-disk' is required."
assert isSet "${BOOT_KEY}" \
  error "the option '-b, --boot-key' is required."
assert isSet "${ROOT_SIZE}" \
  error "the option '-R, --root-size' is required."
assert isSet "${SWAP_SIZE}" \
  error "the option '-S, --swap-size' is required."

# Check that we are NOT Setting up the system and the boot-key on the same disk
assert isNotMainDisk "${BOOT_KEY}" \
  error "options main-disk and boot-key refer to the same device: ${BOOT_KEY}"

MAIN_DISK_SIZE=$(blockdev --getsize64 "${MAIN_DISK}")
# Reserve 16MiB for the partition table and LVM header
METADATA=$(toBytes 16M)

if ! isSet "${HOME_SIZE}"; then
  EMPTY_SPACE=$((MAIN_DISK_SIZE - METADATA - ROOT_SIZE - SWAP_SIZE))
  EMPTY_SPACE=$(max 0 "${EMPTY_SPACE}")

  HOME_SIZE=0

  if [[ ${EMPTY_SPACE} -ne 0 ]]; then
    assert isZeroOrAtLeast4MiB "${EMPTY_SPACE}" \
      error "there is only $(byteToString "${EMPTY_SPACE}") available. Home partition size must be either 0 or at least 4MiB."

    read -r -p \
      "Would you like to allocate the remaining $(byteToString "${EMPTY_SPACE}") to the home partition? [y/N] " \
      REPLY

    # Assign remaining empty space minus a 16MiB metadata buffer to the home partition
    if [[ "${REPLY}" == y ]]; then
      HOME_SIZE=${EMPTY_SPACE}
    fi
  fi
fi

if [[ "${RESUME}" == false ]]; then
  # Warn about zero-sized partitions and ask for confirmation
  assert isNotZero "${SWAP_SIZE}" \
    confirmContinue "no space allocated for SWAP."
  assert isNotZero "${HOME_SIZE}" \
    confirmContinue "no space allocated for the home partition."

  # Check that partition sizes are consistent with total available empty space
  TOTAL_INSTALL_SIZE=$((METADATA + ROOT_SIZE + SWAP_SIZE + HOME_SIZE))

  function mainDiskCanContainPartitions { [[ $1 -le ${MAIN_DISK_SIZE} ]]; }

  assert mainDiskCanContainPartitions "${TOTAL_INSTALL_SIZE}" \
    error \
    "not enough empty space to store metadata and partitions.
       Need at least $(byteToString "${TOTAL_INSTALL_SIZE}"), but has only $(byteToString "${MAIN_DISK_SIZE}") available. Remember that 16MiB are reserved for storing metadata."

  # Ask for confirmation before destroying existing partitions on main disk and boot-key
  if ! isRunningUnitTest; then
    PARTITION_LIST="$(concat "\n" "$(listPartitions "${MAIN_DISK}")" "$(listPartitions "${BOOT_KEY}")")"

    if ! isEmpty "${PARTITION_LIST}"; then
      echo -e "Found existing data on one or both of the following devices: ${MAIN_DISK}, ${BOOT_KEY} :\n"
      for partition in ${PARTITION_LIST}; do
        printf "%s\n\n" "$(list5LargestFilesOnPartition "${partition}")"
      done
      confirmContinue "The installation process will permanently delete the device content listed above!"
    fi
  fi
fi

if [[ "${RESUME}" == false ]]; then
  # Show planned partition layout
  BOOT_KEY_SIZE=$(blockdev --getsize64 "${BOOT_KEY}")

  printSummary "${MAIN_DISK}" "${MAIN_DISK_SIZE}" "${BOOT_KEY}" "${BOOT_KEY_SIZE}" \
    "${ROOT_SIZE}" "${SWAP_SIZE}" "${HOME_SIZE}"

  countDown 5 "Starting in 5 seconds"
fi

# Stop script execution beyond this point and signal success while running
# unit-tests. Acts as a separator between pure operations and those with
# side-effects. Activated by the -t flag on the command line.
if isRunningUnitTest; then
  exit 0
fi

trap messageOnAbort EXIT

if [[ -z "${CHECKPOINT_ID}" ]]; then
  heading "Setting Up Installation Tools..."

  subheading "Checking internet connection..."
  assert hasInternetAccess "" \
    error \
    "unable to reach the internet.
       For more information about how to configure your network interface,
       please consult the NixOS manual at:
       https://nixos.org/manual/nixos/stable/#sec-installation-manual-networking"

  subheading "Installing software dependencies..."
  nix-env -iA age -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  nix-env -iA b3sum -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  nix-env -iA pv -f https://github.com/NixOS/nixpkgs/archive/1732ee9120e43c1df33a33004315741d0173d0b2.tar.gz
  saveCheckPoint tools-installed
fi

if [[ "${CHECKPOINT_ID}" == tools-installed ]]; then
  if [[ "${WIPE_DISKS}" == true ]]; then
    heading "Wiping Disks..."

    subheading "Wiping boot-key..."
    fillWithRandomData "${BOOT_KEY}"

    subheading "Wiping main disk..."
    warn "Depending on your hardware, this step can take hours to complete!"
    fillWithRandomData "${MAIN_DISK}"
  fi
  saveCheckPoint disks-wiped
fi

if [[ "${CHECKPOINT_ID}" == disks-wiped ]]; then
  heading "Preparing Boot-Key..."

  subheading "Creating a bootable 2GiB ESP partition on ${BOOT_KEY}"
  # Create a partition table
  quiet parted --script --align optimal "${BOOT_KEY}" -- mklabel gpt
  # Create a 2GiB boot partition named ESP after the partition table.
  # This is where the kernel and initramdisk is installed.
  quiet parted --script --align optimal "${BOOT_KEY}" -- mkpart ESP 1MiB 2049MiB
  # make ESP bootable.
  quiet parted --script "${BOOT_KEY}" -- set 1 boot on

  subheading "Formatting ESP partition..."
  mkfs.fat -F 32 -n ESP -- "${BOOT_KEY}1"
  saveCheckPoint boot-key-ready
fi

if [[ "${CHECKPOINT_ID}" == boot-key-ready ]]; then
  heading "Preparing Main Disk..."

  subheading "Generating keyfile..."
  # Generate an 8MiB key file to open the LUKS2 container on the main disk.
  # For extra safety, the secret in the key file is kept on a section of RAM that
  # will never be swapped out to disk.
  mkdir -p -- /root/secrets/
  mount -t ramfs -- none /root/secrets

  dd if=/dev/urandom \
    of=/root/secrets/luks-keyfile \
    bs=$(((8 * 1024 * 1024) - 1)) \
    count=1 \
    2>/dev/null

  subheading "Creating partition table on ${MAIN_DISK}..."
  quiet parted --script --align optimal "${MAIN_DISK}" -- mklabel gpt

  subheading "Creating LUKS2 container on ${MAIN_DISK}..."
  cryptsetup luksFormat \
    --batch-mode \
    --use-urandom \
    --type luks2 \
    --cipher aes-xts-plain64 \
    --pbkdf argon2id \
    --key-size 512 \
    --hash sha512 \
    --key-file /root/secrets/luks-keyfile \
    --header /root/secrets/luks-header \
    -- "${MAIN_DISK}"

  subheading "Opening LUKS2 container on ${MAIN_DISK}..."
  cryptsetup open "${MAIN_DISK}" lukscontainer \
    --key-file /root/secrets/luks-keyfile \
    --header /root/secrets/luks-header

  # From: https://wiki.archlinux.org/title/LVM#Advantages
  #       https://wiki.archlinux.org/title/Ext4#Bytes-per-inode_ratio
  #       https://wiki.archlinux.org/title/Ext4#Reserved_blocks
  #
  # Root and home partitions will live on separate logical volumes. The nix store
  # can grow large fairly quickly with each generation. However, LVM allows us to
  # "dynamically" resize logical volumes if necessary. We elect to use ext4
  # filesystems which support online resizing.
  #
  subheading "Creating LVM volume in LUKS2 container..."
  pvcreate /dev/mapper/lukscontainer
  vgcreate vg_nixos /dev/mapper/lukscontainer

  subheading "Creating root, swap and home partitions..."
  lvcreate --size "${ROOT_SIZE}b" --name root vg_nixos

  if [[ ${SWAP_SIZE} -gt 0 ]]; then
    lvcreate --size "${SWAP_SIZE}b" --name swap vg_nixos
  fi
  if [[ ${HOME_SIZE} -gt 0 ]]; then
    lvcreate --size "${HOME_SIZE}b" --name home vg_nixos
  fi

  subheading "Formatting root, swap and home partitions..."
  mkfs.ext4 -L root -q /dev/vg_nixos/root

  if [[ ${SWAP_SIZE} -gt 0 ]]; then
    mkswap -L swap /dev/vg_nixos/swap
  fi
  if [[ ${HOME_SIZE} -gt 0 ]]; then
    mkfs.ext4 -L home -q /dev/vg_nixos/home
  fi

  saveCheckPoint main-disk-ready
fi

if [[ "${CHECKPOINT_ID}" == main-disk-ready ]]; then
  heading "Preparing for NixOS Installation..."

  subheading "Mounting partitions..."
  mount /dev/vg_nixos/root /mnt
  mkdir -p /mnt/boot
  mount "${BOOT_KEY}1" /mnt/boot

  if [[ ${HOME_SIZE} -gt 0 ]]; then
    mkdir -p /mnt/home
    mount /dev/vg_nixos/home /mnt/home
  fi

  if [[ ${SWAP_SIZE} -gt 0 ]]; then
    subheading "Activating swap partition..."
    swapon /dev/vg_nixos/swap
  fi

  saveCheckPoint mount-points-ready
fi

if [[ "${CHECKPOINT_ID}" == mount-points-ready ]]; then
  subheading "Encrypting LUKS2 container header and key files..."
  # Destination directory for archive inclusion in initramfs
  mkdir -p /mnt/etc/nixos/initrd/secrets

  cat <<-END

  ------------------------------------------------------------------------------
  Please provide a passphrase to protect your emcryption keyfile. Note that you
  must provide the SAME passphrase each time you start your computer.
  The passphrase is necessary to unlock your LUKS container, and mount device
  partitions.

  The longer and stronger the passphrase, the more protection it gives you.
  Dice-generated passphrases are an example of strong, easy-to-remember
  passphrases.

  You can find a guide to make one at this address:

  https://www.eff.org/dice

  Or, let $(basename "$0") do it for you.
  ------------------------------------------------------------------------------

END

  # Compress and encrypt header and key files
  PASSPHRASE=$(tar -C /root/secrets -cz luks-keyfile luks-header -f - \
    | age --encrypt --passphrase --output /mnt/etc/nixos/initrd/secrets/secboot 2>&1)

  # Auto-generated passphrase
  if [[ -n "${PASSPHRASE}" ]]; then
    cat <<-END

  ------------------------------------------------------------------------------
  Write down your autogenerated passphrase, and keep it in a secure location.

  $(echo -n "${PASSPHRASE#Using the autogenerated passphrase}" | tr -d '".')


  Hit Enter to continue.
END
    read -r -n 1
  fi

  subheading "Saving backup copy for system rescue..."
  mkdir -p /mnt/boot/EFI/extended/
  cp /mnt/etc/nixos/initrd/secrets/secboot /mnt/boot/EFI/extended/

  saveCheckPoint secrets-encrypted
fi

if [[ "${CHECKPOINT_ID}" == secrets-encrypted ]]; then
  subheading "Generating Full-Disk Encryption (FDE) configuration file..."

  BOOT_KEY_WWID="$(findWWID "${BOOT_KEY}1")"
  MAIN_DISK_WWID="$(findWWID "${MAIN_DISK}")"
  DATETIME="$(date -Iseconds)"

  mkdir -p /mnt/etc/nixos/
  cat <<END >|/mnt/etc/nixos/fde-configuration.nix
#|- fde-configuration.nix/${VERSION}

################################################################################
# Full disk encryption configuration file
#
# This file was auto-generated at installation time. You should not edit it
# manually. Instead use \`bk\` to adjust the settings.
#
# However, if you must, limit yourself to the 'settings' attribute-set below.
################################################################################

{ config, lib, pkgs, ... }:
  let
    settings = {
      # Primary boot-key.
      primary = {
          id = "${BOOT_KEY_WWID}";
          label = "primary";
          creationDate = "${DATETIME}";
          lastUpdated = "${DATETIME}";
          hash = "0000000000000000000000000000000000000000000000000000000000000000";
        };
      # List of backup boot-keys.
      backups = [];
      # Maximum number of decryption attempts before program termination
      # range [1-65535].
      maxAttempts = 3;
      # Mount location of the primary boot-key.
      mountPoint = "/boot";
      # Refuse to boot from a bootkey other than the primary or a member
      # of the backup list if set to 'true'.
      checkBootkeyIntegrity = false;
      # Location of the archive containing a LUKS keyfile and header file
      # necessary for device decryption.
      decryptionFile = "/etc/nixos/initrd/secrets/secboot";
      # Default location of the archive containing files necessary to rescue a
      # full-disk encrypted NixOS system (path relative to the mount point of
      # a bootkey).
      rescueFile = "EFI/extended/secboot";
    };
  in
    {
      ##########################################################################
      # Boot key mount location.
      # fileSystems.<name>.device
      #
      # <name> MUST be the same as the EFI System Partition mount point option
      # 'boot.loader.efi.efiSysMountPoint' in etc/nixos/comfiguration.nix,
      # By default <name> = "/boot".
      #
      # For example if you choose "/efi" as the mount point:
      #
      #     boot.loader.efi.efiSysMountPoint = "/efi";
      #
      # you must adjust the attribute settings.mountPoint accordingly
      #
      # settings = {
      # ...
      #     mountPoint ="/efi";
      # ...
      #     };
      #
      # Otherwise, new build generations will not be added to your boot-key.
      #
      ##########################################################################

      fileSystems."\${settings.mountPoint}" = {
        # lib.mkForce: assigns the highest priority to an attribute value,
        # preventing it from being modified by another module.
        device = lib.mkForce "/dev/disk/by-id/\${settings.primary.id}";

        # "noauto"        Can only be mounted explicitly
        # "X-mount.mkdir" Allow to make a target directory (mountpoint) if it
        #                 does not exist yet.
        options = ["noauto" "X-mount.mkdir"];
        };


      ##########################################################################
      # FIXME Create a statically linked AGE to add to initrd.
      #
      # Using a dynamically linked version (the default in nixpkgs) leads to
      # extraUtilsCommandsTest failing with the following error message during
      # the derivation's build phase:
      #
      # Segmentation fault      (core dumped) \$out/bin/age --version
      #
      # Note: statically linking glibc is discouraged, since glibc statically
      # linked programs can have multiple "copies of the C library in its
      # address space, and they might fight over whose stdout buffer is to be
      # used, who gets to call sbrk with a nonzero argument, that sort of thing.
      # There is a bunch of defensive logic inside glibc to try to make this
      # work, but it's never been guaranteed to work".  see:
      # https://stackoverflow.com/questions/57476533/why-is-statically-linking-glibc-discouraged
      #
      # There are nixpkgs static package sets linked with musl currently in the
      # works, but lacking documentation at the moment. When ready,
      # pkgsStatic.age should be a good alternative.
      # see: https://github.com/NixOS/nixpkgs/issues/227807
      ##########################################################################

      nixpkgs.overlays = [
        (self: super: {
           age-static = super.age.overrideAttrs
             (final: prev: {
                # Package dependencies
                buildInputs = [ pkgs.stdenv pkgs.go pkgs.glibc.static ];
                CFLAGS="-I\${pkgs.glibc.dev}/include";
                LDFLAGS="-L\${pkgs.glibc}/lib";

                # Tags and ldflags taken from
                # https://github.com/golang/go/issues/26492#issuecomment-837053426
                tags = "osusergo,netgo,static";

                # Blend of original package flags at
                # https://github.com/NixOS/nixpkgs/blob/3751e1e40bfbcc2072b21a800387d87aa52c11c0/pkgs/tools/security/age/default.nix#L36
                # and those taken from golang repo
                ldflags = [
                  "-s" "-w" "-X main.Version=\${prev.version}"
                  "-linkmode external" "-extldflags '-static'"
                  ];

                # This is a statically linked binary, but patchelf is expecting
                # a dynamically linked file. It emits errors, and aborts the
                # build if enabled.
                dontPatchELF = true;

              });
        })
        ];

      boot.initrd = {
        kernelModules = [ "uas" "usbcore" "usb_storage" "usb_common"
                          "vfat" "nls_cp437" "nls_iso8859_1" ];

        ########################################################################
        # Add statically linked AGE to initrd
        ########################################################################
        extraUtilsCommands = '' copy_bin_and_libs \${pkgs.age-static}/bin/age '';
        extraUtilsCommandsTest = '' \$out/bin/age --version '';

        ########################################################################
        # The key file and header necessary to decrypt the LUKS drive are kept
        # in a gzip-compressed encrypted archive.
        # They will be included in the initramfs.
        ########################################################################

        secrets = { "/secboot" = "\${settings.decryptionFile}"; };

        luks.devices."lukscontainer" = {
          device = "/dev/disk/by-id/${MAIN_DISK_WWID}";
          preLVM = false; # run postDeviceCommands before attempting decryption
          allowDiscards = true;
          keyFile = "/secrets/luks-keyfile";
          header  = "/secrets/luks-header";
          postOpenCommands = ''
            # Securely delete secrets from memory after successful drive decryption
            shred -n 10 -z -u -- /secrets/luks-keyfile
            shred -n 10 -z -u -- /secrets/luks-header
            umount /secrets 2>/dev/null
            rm -rf /secrets
          '';
          };
      };

      boot.initrd.postDeviceCommands = ''
        ########################################################################
        # Defining the helper functions and main program inside a nested
        # function has two advantages:
        #
        #   1 - every inner variable or function defined inside the host
        #       function is local.
        #
        #   2 - if there is a name collision between a function outside the
        #       host function and an inner function, the inner function takes
        #       precedence.
        #
        #       e.g.
        #             # Definitions
        #             function a {
        #                echo "outer a"
        #             }
        #
        #             b () ( # note the parenthesis instead of a curly brace
        #               function a {
        #                   echo "inner a"
        #                 }
        #                a
        #             )
        #
        #             # Execution
        #             a
        #             b
        #             a
        #
        #             # Output
        #             outer a
        #             inner a
        #             outer a
        ########################################################################

        setupLUKSOpenContext () (
          ######################################################################
          #             HELPER FUNCTIONS
          ######################################################################

          ######################################################################
          # Securely delete a file or files in a directory (recursive).
          # Arguments:
          #   File or directory name
          # Returns:
          #   0 if files were deleted, non-zero on error
          ######################################################################
          function shredFile {
            local file_or_dir="\$1"

            if [[ -f "\$file_or_dir" ]]; then
              shred -n 10 -z -- "\$file_or_dir"
            else
              for file in "\$file_or_dir"/*; do
                shredFile "\$file"
              done
            fi
          }

          ######################################################################
          # Create a ramfs directory to hold secrets and temporary files.
          # Files kept in this directory will never be swapped out to disk,
          # preservng their confidentiality.
          # Arguments:
          #   Directory path
          # Returns:
          #   0 if directory was created, non-zero on error
          ######################################################################
          function createRamfsDir {
            local dir_path="\$1"

            mkdir -m 0755 -p \$dir_path
            mount -t ramfs none \$dir_path
          }

          ######################################################################
          # Securely delete a ramfs directory.
          # Arguments:
          #  Directory name
          # Returns:
          #   0 if directory was deleted, non-zero on error
          ######################################################################
          function deleteRamfsDir {
            local ramfs_dir="\$1"

            shredFile \$ramfs_dir
            umount \$ramfs_dir 2>/dev/null
            rm -rf \$ramfs_dir
          }

          ######################################################################
          # Setup AGE's decryption context.
          # Arguments:
          #  None
          # Returns:
          #   0 if decryption context was set, non-zero on error
          ######################################################################
          function setupAGEContext {
            # When called from the terminal age opens /dev/tty to read the
            # passphrase with no echo. See:
            # https://github.com/FiloSottile/age/blob/36ae5671cfbb88c591c87a900b2c9a12999ea3b7/cmd/age/tui.go#L105
            #
            # Unfortunately during boot, keyboard input is taken from
            # /dev/console. If left as-is, we get the following error message,
            # and are unable to go any further.
            #
            # age: error: could not read passphrase: could not read passphrase: open /dev/tty: no such device or address
            #
            # As a work-around we create a temporary symlink /dev/tty -> /dev/console.

            if [[ -e /dev/tty ]]; then
               mv /dev/tty /dev/tty.orig
            fi

            ln -s /dev/console /dev/tty
          }

          ######################################################################
          # Tear down AGE decryption context.
          # Arguments:
          #   None
          # Returns:
          #   0 if the original tty is restored, non-zero on error
          ######################################################################
          function teardownAGEContext {
            # Delete symlink
            rm -f /dev/tty
            if [[ -e /dev/tty.orig ]]; then
               mv /dev/tty.orig /dev/tty
            fi
          }

          ######################################################################
          # Execute an error function if a predicate function returns false.
          # Arguments:
          #   Predicate function
          #   Argument to test
          #   Error function to execute if assertion is false
          #   Error message
          # Outputs:
          #   Nothing if the predicate is true. The error function's output
          #   otherwise.
          ######################################################################
          function assert {
            local pred_fun="\$1"
            local pred_arg="\$2"
            local error_fun="\$3"
            local error_msg="\$4"

            if ! \$pred_fun "\$pred_arg"; then
              \$error_fun "\$error_msg"
            fi
          }

          ######################################################################
          # Print panic menu.
          # Arguments:
          #   Error message
          # Outputs:
          #   Menu on panic for rebooting or halting the system
          ######################################################################
          function failWith {
            {
              echo
              echo "Fatal Error: \$1"
              echo

              echo "An error occurred in stage 1 of the boot process."
              echo "Press one of the following keys:"
              echo
              echo "  r) to reboot immediately"
              echo "  *) to shut down"
            } >&2

            read -n 1 reply </dev/console

            if [[ "\$reply" = r ]]; then
                echo "Rebooting..."
                reboot -f
            else
                echo "Halting..."
                halt -f
            fi
          }

          ######################################################################
          # Determine if the maximum number of decryption attempts is reached.
          # Arguments:
          #   Attempt count
          # Outputs:
          #   A five-second delay message before the next attempt
          # Returns:
          #   0 if the maximum number of attempts was NOT reached,
          #   non-zero otherwise
          ######################################################################
          function canRetry {
            local cnt="\$1"

            if [[ \$cnt -lt "\${toString settings.maxAttempts}" ]]; then
              echo -n "Next attempt in 5 seconds"
              for i in \$(seq 5); do
                echo -n "."
                sleep 1
              done
              echo
              return 0
            fi
            return 1
          }

          ######################################################################
          # Setup authentication environment.
          # Arguments:
          #   None
          # Returns:
          #   0 if the environment was successfully setup,
          #   non-zero otherwise
          ######################################################################
          function setup {
            createRamfsDir /crypt-ramfs
            setupAGEContext
            createRamfsDir /secrets
          }

          ######################################################################
          # Teardowm authentication environment.
          # Arguments:
          #   None
          # Returns:
          #   0 if the environment was successfully torn down,
          #   non-zero otherwise
          ######################################################################
          function teardown {
            teardownAGEContext
            deleteRamfsDir /crypt-ramfs
          }

          ######################################################################
          # Decrypt the compressed LUKS2 key and header file.
          # Arguments:
          #   Encrypted archive
          # Returns:
          #   0 if decryption is successful,
          #   non-zero otherwise
          ######################################################################
          function decryptArchive {
            age --output /crypt-ramfs/archive \\
                --decrypt -- "\$1" \\
                >/dev/null 2>&1
          }

          ######################################################################
          # Decompress LUKS2 key and header file archive.
          # Arguments:
          #   Compressed file
          # Returns:
          #   0 if decompression is successful,
          #   non-zero otherwise
          ######################################################################
          function extractSecrets { tar -xz -C /secrets -f "\$1"; }

          ######################################################################
          # Check that the LUKS2 key and header file were extracted.
          # Arguments:
          #   None
          # Returns:
          #   0 if expected files exist,
          #   non-zero otherwise
          ######################################################################
          function secretFilesExist {
            [[ -f /secrets/luks-keyfile && -f /secrets/luks-header ]]
          }

          ######################################################################
          # Determine if the boot-key used to start the system is registered.
          # Each valid boot-key has its World Wide Identifier (WWID)
          # kept in a list of authorized devices.
          # Before each boot, the id of the device containing the init ramdisk
          # is checked against that list.
          # The system will refuse to boot if it is not on the list.
          # Arguments:
          #   None
          # Returns:
          #   zero if the boot-key is valid, non-zero otherwise
          ######################################################################
          # TODO Determine why device nodes for usb thumbdrives are not created?
          #function isValidBootkeyPresent {
          #  local dualFactorPresent=1

          #  local WWIDs="\${settings.primary.id} \${builtins.concatStringsSep " " (builtins.catAttrs "id" settings.backups)}"
          #  for wwid in \$WWIDs; do
          #    if [[ -e "/dev/disk/by-id/\$wwid" ]]; then
          #      dualFactorPresent=0
          #      break
          #    fi
          #  done

          #  echo "\$dualFactorPresent"
          #}

          ######################################################################
          #                           MAIN PROGRAM
          ######################################################################
          # TODO Decrypt secrets only if a registered boot-key is present
          #
          #
          #if [[ "\${toString settings.checkBootkeyIntegrity}" == true && ! isValidBootkeyPresent ]]; then
          #  failWith "Missing boot-key."
          #fi

          setup
          for cnt in \$(seq "\${toString settings.maxAttempts}"); do
            if decryptArchive /secboot ; then
              assert extractSecrets "/crypt-ramfs/archive" \\
                failWith "Unable to extract archive."
              assert secretFilesExist "" \\
                failWith "Missing boot-key."
              break
            else
              echo "Failed attempt: \$cnt out of \${toString settings.maxAttempts}"
              assert canRetry "\$cnt" \\
                failWith "Exceeded maximum number of attempts."
            fi
          done
          teardown
          echo "Authentication successful."
      )
      setupLUKSOpenContext
        '';
    }
END

  saveCheckPoint fde-configuration-done
fi

if [[ "${CHECKPOINT_ID}" == fde-configuration-done ]]; then
  subheading "Generating NixOS configuration files..."
  nixos-generate-config --root /mnt

  # Add fde-configuration.nix to imports list in configuration.nix
  sed -i 's/hardware-[a-z\.]*/hardware-configuration\.nix\n      \.\/fde-configuration\.nix/' \
    /mnt/etc/nixos/configuration.nix

  saveCheckPoint nixos-configuration-done
fi
